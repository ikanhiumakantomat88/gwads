-- Bundled Lua Script
-- Generated by Lua Bundler
-- https://github.com/alfin-efendy/lua-bundler

local EmbeddedModules = {}

-- Module: auto/events.lua
EmbeddedModules["auto/events.lua"] = function()
    local m = {}

    local Window
    local Core

    local Events
    local EventUtility
    local EventReplion
    local TierUtility
    local Net

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        Events = require(Core.ReplicatedStorage.Events)
        EventUtility = require(Core.ReplicatedStorage.Shared.EventUtility)
        TierUtility = require(Core.ReplicatedStorage.Shared.TierUtility)
        Net = require(Core.ReplicatedStorage.Packages.Net)

        local replion = require(Core.ReplicatedStorage.Packages.Replion)
        EventReplion = replion.Client:WaitReplion("Events")

        Core:MakeLoop(function()
            return Window:GetConfigValue("AutoBuyWeatherMachine")
        end, function()
            self:AutoBuyWeatherMachine()
        end)
    end

    function m:GetListWeathersMachine()
        local weatherList = {}

        for weather, _ in pairs(Events) do
            local event = EventUtility:GetEvent(weather)
            if not event then
                warning("Event not found: " .. weather)
                continue
            end

            if not event.WeatherMachine then
                continue
            end

            if not event.WeatherMachinePrice then
                continue
            end

            local tierIndex = event.Tier or 100
            local tierDetail = TierUtility:GetTier(tierIndex)

            table.insert(weatherList, {
                Name = event.Name,
                Price = event.WeatherMachinePrice,
                Description = event.Description or "No description available.",
                Tier = tierDetail and tierDetail.Name or "Unknown",
                TierIndex = tierIndex,
            })
        end

        table.sort(weatherList, function(a, b)
            if a.TierIndex == b.TierIndex then
                return a.Name < b.Name
            end
            return a.TierIndex < b.TierIndex
        end)

        return weatherList
    end

    function m:BuyWeatherMachine(weatherName)
        local buyEvent = Net:RemoteFunction("PurchaseWeatherEvent")

        buyEvent:InvokeServer(weatherName)
    end

    function m:AutoBuyWeatherMachine()
        if not Window:GetConfigValue("AutoBuyWeatherMachine") then
            return
        end
        local selectedWeathers = Window:GetConfigValue("WeatherMachineItem") or {}
        local currentWeather = EventReplion:GetExpect("Events") or {}

        local owned = {}
        for _, name in pairs(currentWeather) do
            owned[name] = true
        end

        for _, weatherName in ipairs(selectedWeathers) do
            if owned[weatherName] then
                continue
            end

            self:BuyWeatherMachine(weatherName)
        end
    end

    return m
end

-- Module: auto/enchant.lua
EmbeddedModules["auto/enchant.lua"] = function()
    local m = {}

    local Window
    local Core
    local Player

    local Net
    local Replion
    local PlayerStatsUtility 
    local ItemUtility
    local TierUtility

    local DataReplion

    function m:Init(_window, _core, _player)
        Window = _window
        Core = _core
        Player = _player

        Net = require(Core.ReplicatedStorage.Packages.Net)
        Replion = require(Core.ReplicatedStorage.Packages.Replion)
        PlayerStatsUtility = require(Core.ReplicatedStorage.Shared.PlayerStatsUtility)
        ItemUtility = require(Core.ReplicatedStorage.Shared.ItemUtility)
        TierUtility = require(Core.ReplicatedStorage.Shared.TierUtility)

        DataReplion = Replion.Client:WaitReplion("Data")

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoEnchant1")
            end,
            function()
                self:StartAutoEnchant1()
            end
        )
    end

    function m:ListInventoryEnchantStones()
        local inventory = DataReplion:GetExpect({ "Inventory" })
        local items = inventory and inventory["Items"] or {}
        local enchantStones = {}

        if not items then
            return enchantStones
        end

        for _, item in pairs(items) do
            local itemData = ItemUtility.GetItemDataFromItemType("EnchantStones", item.Id)
            if not itemData or not itemData.Data then
                continue
            end

            if itemData.Data.Type ~= "EnchantStones" then
                continue
            end

            table.insert(enchantStones, {
                UUID = item.UUID,
                Id = item.Id,
                Name = itemData.Data.Name or "Unknown",
                Type = itemData.Data.Type or "Unknown",
            })
        end

        return enchantStones
    end

    function m:EquipEnchantStone(unequipItemUUID)
        local enchantStones = self:ListInventoryEnchantStones()
        if #enchantStones == 0 then
            warning("No enchant stones found in inventory.")
            return
        end

        Net:RemoteEvent("UnequipItem"):FireServer(unequipItemUUID)
        task.wait(0.15)
        Net:RemoteEvent("EquipItem"):FireServer(enchantStones[1].UUID, enchantStones[1].Type)
    end

    function m:GetCurrentRodDetails()
        local equippedItem = DataReplion:GetExpect("EquippedItems")
        local inventoryItem = PlayerStatsUtility:GetItemFromInventory(DataReplion, function(item)
            return item.UUID == equippedItem[1]
        end)

        if not inventoryItem then
            warning("No item equipped in the first slot.")
            return nil
        end

        local inventory = DataReplion:GetExpect({ "Inventory" })
        local inventoryFisihingRods = inventory["Fishing Rods"] or {}
        local metadata = nil
        for _, item in pairs(inventoryFisihingRods) do
            if item.UUID == inventoryItem.UUID then
                metadata = item.Metadata
                break
            end
        end

        local enchant1 = "None"
        local enchant2 = "None"

        for k, v in pairs(inventoryItem.Metadata or {}) do
            local enchantData = ItemUtility:GetEnchantData(v)

            if k == "EnchantId" then
                enchant1 = enchantData.Data.Name
            elseif k == "EnchantId2" then
                enchant2 = enchantData.Data.Name
            end
        end

        local equippedItemData = ItemUtility.GetItemDataFromItemType("Fishing Rods", inventoryItem.Id)
        local tierIndex = equippedItemData.Data.Tier or 100
        local tierDetail = TierUtility:GetTier(tierIndex)
        return {
            UUID = inventoryItem.UUID,
            Id = inventoryItem.Id,
            Name = equippedItemData.Data.Name or "Unknown",
            Tier = tierDetail.Name or "Unknown",
            TierIndex = tierIndex,
            Power = equippedItemData.ClickPower or 0,
            MaxWeight = equippedItemData.MaxWeight or 0,
            Resilience = equippedItemData.Resilience or 0,
            Luck = equippedItemData.Data.BaseLuck or 0,
            Enchant1 = enchant1,
            Enchant2 = enchant2,
        }
    end

    function m:GetListEnchant()
        local enchantList = {}
        local enchantData = require(Core.ReplicatedStorage.Enchants)

        for _, v in pairs(enchantData) do
            table.insert(enchantList,  v.Data.Name)
        end

        table.sort(enchantList)

        return enchantList
    end

    function m:StartAutoEnchant1()
        if not Window:GetConfigValue("AutoEnchant1") then
            return
        end

        local targetEnchant = Window:GetConfigValue("TargetEnchant1") or {}
        local currentRod = self:GetCurrentRodDetails()
        if not currentRod then
            warning("No fishing rod equipped.")
            return
        end

        if table.find(targetEnchant, currentRod.Enchant1) then
            print("Target enchant already applied to the current rod.")
            return
        end

        local altarPosition = CFrame.new(3234.55444, -1302.85486, 1400.52197, 0.354458153, -3.30675043e-08, -0.935071886, -2.43329872e-08, 1, -4.45875159e-08, 0.935071886, 3.85574985e-08, 0.354458153)
        local currentPosition = Player:GetPosition().Position
        local flatCurrentPosition = Vector3.new(currentPosition.X, 0, currentPosition.Z)
        local flatAltarPosition = Vector3.new(altarPosition.X, 0, altarPosition.Z)

        if (flatCurrentPosition - flatAltarPosition).Magnitude ~= 0 then
            Player:TeleportToPosition(altarPosition)
            wait(1)
        end

        local equippedItem = DataReplion:GetExpect("EquippedItems")
        local hotBarIndex = nil
        for k, v in pairs(equippedItem) do
            local inventoryItem = PlayerStatsUtility:GetItemFromInventory(DataReplion, function(item)
                return item.UUID == v
            end)

            if not inventoryItem then
                continue
            end

            local itemData = ItemUtility:GetItemData(inventoryItem.Id)

            if itemData.Data.Type == "EnchantStones" then
                hotBarIndex = k
                break
            end
        end

        if not hotBarIndex then
            self:EquipEnchantStone(equippedItem[#equippedItem])
            hotBarIndex = #equippedItem
        end

        Net:RemoteEvent("EquipToolFromHotbar"):FireServer(hotBarIndex)
        wait(0.15)
        Net:RemoteEvent("ActivateEnchantingAltar"):FireServer()
    end

    return m
end

-- Module: auto/trade.lua
EmbeddedModules["auto/trade.lua"] = function()
    local m = {}

    local Window
    local Core

    local ItemData
    local ItemUtility
    local TierUtility
    local Replion
    local DataReplion
    local Net
    local Promise
    local RemoteAwaitTradeResponse
    local PromptEvent
    local Constants

    m.TradeItems = {}

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        ItemData = require(Core.ReplicatedStorage.Items)
        ItemUtility = require(Core.ReplicatedStorage.Shared.ItemUtility)
        TierUtility = require(Core.ReplicatedStorage.Shared.TierUtility)
        Replion = require(Core.ReplicatedStorage.Packages.Replion)
        Net = require(Core.ReplicatedStorage.Packages.Net)
        Promise = require(Core.ReplicatedStorage.Packages.Promise)
        Constants = require(Core.ReplicatedStorage.Shared.Constants)

        RemoteAwaitTradeResponse = Net:RemoteFunction("AwaitTradeResponse")

        DataReplion = Replion.Client:WaitReplion("Data")
        self.TradeItems = self:GetListItemsToTrade()

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoGiveItems")
            end,
            function()
                self:StartAutoGive()
            end
        )

        PromptEvent = Instance.new("BindableEvent")
        RemoteAwaitTradeResponse.OnClientInvoke = function(itemType, itemData, sender)
            return self:AcceptTrade(itemType, itemData, sender)
        end
    end

    function m:GetListItemsToTrade()
        local listItems = {}

        for _, itemInfo in pairs(ItemData or {}) do
            local itemData = itemInfo.Data
            if not itemData then
                continue
            end

            local itemType = itemData.Type or "Unknown"
            -- if not table.find(Constants.TradableItemTypes, itemType) then
            --     warning("Item type not tradable for item ID:")
            --     continue
            -- end

            -- if table.find(Constants.PaidTradableItemTypes, itemType) then
            --     warning("Item ID is in non-tradable list:")
            --     continue
            -- end

            local tierIndex = itemData.Tier or 100
            local tierDetail = TierUtility:GetTier(tierIndex)

            table.insert(listItems, {
                Id = itemData.Id,
                Name = itemData.Name or "Unknown",
                Type = itemType,
                Description = itemData.Description or "No Description",
                Rarity = tierDetail and tierDetail.Name or "Unknown",
                RarityIndex = tierIndex,
            })
        end

        table.sort(listItems, function(a, b)
            if a.RarityIndex == b.RarityIndex then
                return a.Name < b.Name
            else
                return a.RarityIndex < b.RarityIndex
            end
        end)

        return listItems
    end

    function m:FindItemById(itemId)
        for _, itemDetail in pairs(self.TradeItems) do
            if itemDetail.Id == itemId then
                return itemDetail
            end
        end
        return nil
    end

    function m:GetListInventoryItems()
        local inventoryItems = {}
        print("Fetching inventory data...")
        local inventory = DataReplion:GetExpect({ "Inventory" })

        if not inventory or #inventory == 0 then
            warning("No inventory data found")
            return inventoryItems
        end

        print("Listing inventory items...")
        for _, v in pairs(inventory) do
            print("Processing item type:", _, "with", #v, "items")
            for _, items in pairs(v) do
                if not items.Id then
                    warning("Item ID not found")
                    continue
                end

                if not items.UUID then
                    warning("Item UUID not found for item ID:", items.Id)
                    continue
                end

                local itemData = self:FindItemById(items.Id)
                if not itemData then
                    warning("Item data not found for item ID:", items.Id)
                    continue
                end

                table.insert(inventoryItems, {
                    UUID = items.UUID,
                    Id = items.Id,
                    Name = itemData.Name or "Unknown",
                    Type = itemData.Type or "Unknown",
                    Description = itemData.Description or "No Description",
                    Rarity = itemData.Rarity or "Unknown",
                    RarityIndex = itemData.RarityIndex or 100,
                    Favorited = items.Favorited or false,
                    Metadata = items.Metadata or {},
                })
            end
        end

        return inventoryItems
    end

    function m:StartAutoGive()
        print("Starting Auto Give Items...")
        if not Window:GetConfigValue("AutoGiveItems") then
            warn("Auto Give Items: Feature is disabled.")
            return
        end

        print("Preparing to start Auto Give Items...")
        local userId = Window:GetConfigValue("GiveToPlayer") or 0
        if userId == 0 then
            warn("Auto Give Items: No UserId specified to give items to.")
            return
        end

        print(string.format("Auto Give Items: Giving items to UserId: %d", userId))
        local itemName = Window:GetConfigValue("GiveItem") or {}
        local minRarity = Window:GetConfigValue("GiveMinRarityItems") or nil
        local dontGiveFavorite = Window:GetConfigValue("DontGiveFavoriteItems") or false

        if #itemName == 0 and not minRarity then
            warn("Auto Give Items: No items or minimum rarity specified to give.")
            return
        end

        --TODO: Bug fixing here (Proccess stop in here)
        print("Starting Auto Give Items...")
        local inventoryItems = self:GetListInventoryItems()
        local itemsToGive = {}

        print(string.format("Found %d tradable items in inventory.", #inventoryItems))
        for _, itemDetail in pairs(inventoryItems) do
            if dontGiveFavorite and itemDetail.Favorited then
                print(string.format("Skipping favorite item: %s", itemDetail.Name))
                continue
            end

            if table.find(itemName, itemDetail.Name) then
                print(string.format("Giving item by name: %s", itemDetail.Name))
                table.insert(itemsToGive, itemDetail)
                continue
            end

            if itemDetail.Type ~= "Fishes" then
                continue
            end

            if itemDetail.RarityIndex and minRarity and itemDetail.RarityIndex >= minRarity then
                print(string.format("Giving item by minimum rarity: %s", itemDetail.Name))
                table.insert(itemsToGive, itemDetail)
                continue
            end
        end

        print(string.format("Total items to give: %d", #itemsToGive))
        while Window:GetConfigValue("AutoGiveItems") and #itemsToGive > 0 do
            print(string.format("Giving item: %s (UUID: %s)", itemDetail.Name, itemDetail.UUID))
            local success, data = Net:RemoteFunction("InitiateTrade"):InvokeServer(
                userId,
                itemDetail.UUID
            )

            if success then
                local itemDetail = table.remove(itemsToGive, 1)

                print(string.format("Successfully gave item: %s", itemDetail.Name))
            else
                warn(string.format("Failed to give item: %s", itemDetail.Name))
            end

            if data then
                print("Server Response:", data)
            end

            task.wait(2)  -- Small delay to prevent spamming the server
        end
    end

    function m:AcceptTrade(itemType, itemData, sender)
        if Window:GetConfigValue("AutoGiveItems") then
            print("Auto Give Items is disabled. Ignoring trade response.")
            return false
        end
        print(string.format("Trade Response Received: ItemType=%s, ItemData=%s, Sender=%s", tostring(itemType), tostring(itemData), tostring(sender)))

        task.wait(1)
        PromptEvent:Fire(true)
        print("Trade Response Processed.")
        task.wait(1)

        return true
    end

    return m
end

-- Module: notification/ui.lua
EmbeddedModules["notification/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Webhook

    local TierData

    function m:Init(_window, _core, _webhook)
        Window = _window
        Core = _core
        Webhook = _webhook

        TierData = require(Core.ReplicatedStorage.Tiers)

        local tab = Window:AddTab({
            Name = "Notifications",
            Icon = "🔔",
        })

        self:DiscordSection(tab)
    end

    function m:DiscordSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Discord Webhook",
            Icon = "🌐",
            Default = true,
        })

        accordion:AddTextBox({
            Name = "Discord Webhook URL (for notifications)",
            Default = "",
            Flag = "DiscordWebhookURL",
            Placeholder = "https://discord.com/api/webhooks/...",
            MaxLength = 500,
        })

        accordion:AddTextBox({
            Name = "Discord Ping ID (optional)",
            Default = "",
            Flag = "DiscordPingID",
            Placeholder = "123456789012345678",
            MaxLength = 50,
        })

        accordion:AddButton({
            Text = "Test Notification",
            Callback = function()
                task.spawn(function()
                    Webhook:TestWebhook()
                end)
            end
        })

        accordion:AddSelectBox({
            Name = "Minimum Rarity for Notifications",
            Options = {"Loading ..."},
            Placeholder = "Select Minimum Rarity",
            Flag = "NotificationMinRarity",
            OnInit = function(api, optionsData)
                local formattedTiers = {}

                for _, tierDetail in pairs(TierData) do
                    table.insert(formattedTiers, {
                        text = tierDetail.Name,
                        value = tierDetail.Tier,
                    })
                end

                optionsData.updateOptions(formattedTiers)
            end,
        })

        accordion:AddToggle({
            Name = "Enable Discord Webhook 🔔",
            Default = false,
            Flag = "EnableDiscordWebhook",
        })
    end

    return m
end

-- Module: teleport/event.lua
EmbeddedModules["teleport/event.lua"] = function()
    local m = {}

    local Window
    local Core
    local Player

    local Events
    local EventUtility
    local EventReplion
    local Net

    m.IsOnEvent = false

    function m:Init(_window, _core, _player)
        Window = _window
        Core = _core
        Player = _player

        Events = require(Core.ReplicatedStorage.Events)
        EventUtility = require(Core.ReplicatedStorage.Shared.EventUtility)
        Net = require(Core.ReplicatedStorage.Packages.Net)

        local replion = require(Core.ReplicatedStorage.Packages.Replion)
        EventReplion = replion.Client:WaitReplion("Events")

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoTeleportToEvent")
            end,
            function()
                self:TeleportToEvent()
            end
        )
    end

    function m:GetListEvents()
        local eventList = {}

        for eventName, _ in pairs(Events) do
            local event = EventUtility:GetEvent(eventName)
            if not event then
                warning("Event not found: " .. eventName)
                continue
            end

            if not event.Coordinates then
                continue
            end

            table.insert(eventList, {
                Name = event.Name,
                Description = event.Description or "No description available.",
                Coordinates = event.Coordinates,
            })
        end

        return eventList
    end

    function m:FindEventPosition(menuRings, selectedEvent)
        local props = {}
        for _, propsModel in pairs(menuRings) do
            if propsModel.Name ~= "Props" then
                continue
            end
            print("Adding props from model: " .. propsModel.Name)
            table.insert(props, table.unpack(propsModel:GetChildren()))
        end
        for _, prop in pairs(props) do
            if prop.Name ~= selectedEvent then
                continue
            end

            print("Found event prop: " .. prop.Name)
            local primaryPart = prop.PrimaryPart or nil
            if primaryPart then
                print("Using primary part: " .. primaryPart.Name)
                primaryPart.CanCollide = true
            end

            return prop:GetPivot().Position
        end
        return nil
    end

    function m:TeleportToEvent()
        if Window:GetConfigValue("AutoTeleportToEvent") == false then
            self.IsOnEvent = false
            return
        end

        local currentEvent = EventReplion:GetExpect("Events") or {}
        local selectedEvent = Window:GetConfigValue("TeleportEvent") or ""

        for _, event in pairs(currentEvent) do
            if event ~= selectedEvent then
                self.IsOnEvent = false
                continue
            end

            self.IsOnEvent = true

            local menuRings = Core.Workspace["!!! MENU RINGS"]:GetChildren()
            local eventPosition = self:FindEventPosition(menuRings, selectedEvent)
            if not eventPosition then
                self.IsOnEvent = false
                return
            end

            local currentPosition = Player:GetPosition().Position
            local flatCurrentPosition = Vector3.new(currentPosition.X, 0, currentPosition.Z)
            local flatEventPosition = Vector3.new(eventPosition.X, 0, eventPosition.Z)
            if (flatCurrentPosition - flatEventPosition).Magnitude ~= 0 then
                Player:TeleportToPosition(eventPosition + Vector3.new(0, 50, 0))
            end

            return
        end

        self.IsOnEvent = false
    end

    return m
end

-- Module: ../module/player.lua
EmbeddedModules["../module/player.lua"] = function()
    local m = {}

    -- Load Core module with error handling
    local Core
    local AntiAFKConnection -- Store the connection reference
    local ReconnectConnection

    -- Queue system for tool equipping
    local ToolQueue = {
        Queue = {},
        IsProcessing = false,
        CurrentTask = nil
    }

    function m:Init(_core)
        if not _core then
            error("Player:Init - Core module is required")
        end
        Core = _core

        -- Store the connection so we can disconnect it later
        AntiAFKConnection = Core.LocalPlayer.Idled:Connect(function()
            Core.VirtualUser:CaptureController()
            Core.VirtualUser:ClickButton2(Vector2.new())
        end)

        ReconnectConnection = Core.GuiService.ErrorMessageChanged:Connect(function()
            local IsSingle = #Core.Players:GetPlayers() <= 1

            --// Join a different server if the player is solo
            if IsSingle then
                Core:HopServer()
                return
            end

            Core:Rejoin()
        end)

        -- Initialize queue system
        ToolQueue.Queue = {}
        ToolQueue.IsProcessing = false
        ToolQueue.CurrentTask = nil
    end

    function m:RemoveAntiAFK()
        -- Disconnect the stored connection
        if AntiAFKConnection then
            AntiAFKConnection:Disconnect()
            AntiAFKConnection = nil
        end
    end

    function m:RemoveReconnect()
        if ReconnectConnection then
            ReconnectConnection:Disconnect()
            ReconnectConnection = nil
        end
    end

    -- ===== QUEUE SYSTEM =====

    -- Add task to queue
    -- tool: Tool object to equip
    -- priority: Number (lower = higher priority, default = 5)
    -- taskFunction: Function to execute after tool is equipped (optional)
    -- callback: Function to call when task is complete (optional)
    function m:AddToQueue(_tool, _priority, _taskFunction, _callback)
        _priority = _priority or 5

        if not _tool or not _tool:IsA("Tool") then
            warn("Player:AddToQueue - Invalid tool provided")
            if _callback then _callback(false, "Invalid tool") end
            return false
        end

        local task = {
            Id = tick(), -- Unique identifier
            Tool = _tool,
            Priority = _priority,
            TaskFunction = _taskFunction,
            Callback = _callback,
            Timestamp = tick()
        }

        -- Insert task into queue
        table.insert(ToolQueue.Queue, task)

        -- Start processing if not already processing
        if not ToolQueue.IsProcessing then
            self:ProcessQueue()
        end

        return true
    end

    -- Process the queue
    function m:ProcessQueue()
        if ToolQueue.IsProcessing or #ToolQueue.Queue == 0 then
            return -- Already processing or queue is empty
        end

        ToolQueue.IsProcessing = true

        while #ToolQueue.Queue > 0 do
            -- Sort queue by priority and timestamp to ensure correct order
            table.sort(ToolQueue.Queue, function(a, b)
                if a.Priority == b.Priority then
                    return a.Timestamp < b.Timestamp -- Earlier added first
                end
                return a.Priority < b.Priority -- Lower priority number first
            end)
            local currentTask = table.remove(ToolQueue.Queue, 1) -- Take first (highest priority) task
            ToolQueue.CurrentTask = currentTask

            -- Equip the tool, ensure it is equipped before proceeding
            if self:GetEquippedTool() ~= currentTask.Tool then
                self:EquipTool(currentTask.Tool)
                task.wait(0.5) -- Small delay to ensure tool is equipped
            end

            -- Execute task function if provided and wait for completion
            local success, result = pcall(function()
                return currentTask.TaskFunction()
            end)

            if currentTask.Callback then
                local callbackSuccess, callbackErr = pcall(currentTask.Callback, success, result)
                if not callbackSuccess then
                    warn("Callback error for tool:", currentTask.Tool.Name, "Error:", callbackErr)
                end
            end

            -- task.wait(0.5)
            self:UnequipTool() -- Unequip after task

            ToolQueue.CurrentTask = nil
            task.wait(0.1) -- Small delay between tasks
        end

        ToolQueue.IsProcessing = false
    end

    -- Get current queue status
    function m:GetQueueStatus()
        return {
            queueSize = #ToolQueue.Queue,
            isProcessing = ToolQueue.IsProcessing,
            currentTask = ToolQueue.CurrentTask and ToolQueue.CurrentTask.Tool.Name or nil
        }
    end

    -- Clear the queue
    function m:ClearQueue()
        ToolQueue.Queue = {}
        ToolQueue.IsProcessing = false
        ToolQueue.CurrentTask = nil
    end

    -- Remove specific task from queue by tool name
    function m:RemoveFromQueue(_toolName)
        if not _toolName then return false end

        for i = #ToolQueue.Queue, 1, -1 do
            if ToolQueue.Queue[i].Tool.Name == _toolName then
                table.remove(ToolQueue.Queue, i)
                return true
            end
        end

        return false
    end

    function m:GetTaskByTool(_tool)
        local tasks = {}
        if not _tool then return nil end

        for _, task in ipairs(ToolQueue.Queue) do
            if task.Tool == _tool then
                table.insert(tasks, task)
            end
        end

        return #tasks > 0 and tasks or nil
    end

    function m:EquipTool(_tool)
        -- Validate inputs
        if not _tool or not _tool:IsA("Tool") then 
            warn("Player:EquipTool - Invalid tool provided")
            return false 
        end

        local humanoid = Core:GetHumanoid()
        local backpack = Core:GetBackpack()

        if not humanoid then
            warn("Player:EquipTool - Humanoid not found")
            return false
        end

        if not backpack then
            warn("Player:EquipTool - Backpack not found")
            return false
        end

        if _tool.Parent ~= backpack then
            warn("Player:EquipTool - Tool not in backpack")
            return false 
        end

        -- Try to equip with error handling
        local success, err = pcall(function()
            humanoid:EquipTool(_tool)
        end)

        if not success then
            warn("Player:EquipTool - Failed to equip:", err)
            return false
        end

        return true
    end

    function m:UnequipTool()    
        local humanoid = Core:GetHumanoid()
        if not humanoid then
            warn("Player:UnequipTool - Humanoid not found")
            return false
        end

        -- Try to unequip with error handling
        local success, err = pcall(function()
            humanoid:UnequipTools()
        end)

        if not success then
            warn("Player:UnequipTool - Failed to unequip:", err)
            return false
        end

        return true
    end

    function m:GetEquippedTool()
        local character = Core:GetCharacter()
        if not character then 
            warn("Player:GetEquippedTool - Character not found")
            return nil 
        end

        for _, item in ipairs(character:GetChildren()) do
            if item:IsA("Tool") then
                return item
            end
        end

        return nil
    end

    function m:MoveToPosition(_position)
        local humanoid = Core:GetHumanoid()
        if humanoid then
            humanoid:MoveTo(_position)
        else
            warn("Player:MoveToPosition - Humanoid not found")
        end
    end

    function m:TeleportToPosition(_position)
        local hrp = Core:GetHumanoidRootPart()
        if hrp then
            if typeof(_position) == "Vector3" then
                hrp.CFrame = CFrame.new(_position)
            elseif typeof(_position) == "CFrame" then
                hrp.CFrame = _position
            else
                warn("Player:TeleportToPosition - Invalid position type")
                return false
            end
            return true
        end
        return false
    end

    function m:GetPosition()
        local hrp = Core:GetHumanoidRootPart()
        if not hrp then
            warn("Player:GetPosition - HumanoidRootPart not found")
            return CFrame.new(0, 0, 0)
        end

        return hrp.CFrame or CFrame.new(0, 0, 0)
    end

    function m:GetAllTools()
        local backpack = Core:GetBackpack()
        if not backpack then 
            warn("Player:GetAllTools - Backpack not found")
            return {} 
        end

        local tools = {}
        local success, err = pcall(function()
            for _, item in ipairs(backpack:GetChildren()) do
                if item:IsA("Tool") then
                    table.insert(tools, item)
                end
            end
        end)

        if not success then
            warn("Player:GetAllTools - Error getting tools:", err)
            return {}
        end

        return tools
    end

    function m:GetTool(_toolName)
        if not _toolName or type(_toolName) ~= "string" then
            warn("Player:GetTool - Invalid tool name")
            return nil
        end

        local backpack = Core:GetBackpack()
        if not backpack then
            warn("Player:GetTool - Backpack not found")
            return nil 
        end

        local tool = nil
        local success, err = pcall(function()
            tool = backpack:FindFirstChild(_toolName)
            if tool and not tool:IsA("Tool") then
                tool = nil
            end
        end)

        if not success then
            warn("Player:GetTool - Error finding tool:", err)
            return nil
        end

        if not tool then
            warn("Player:GetTool - Tool not found:", _toolName)
        end

        return tool
    end

    return m
end

-- Module: farm/webhook.lua
EmbeddedModules["farm/webhook.lua"] = function()
    local m = {}

    local Window
    local Core
    local Discord

    local PlayerName

    local TierUtility
    local ItemUtility

    function m:Init(_window, _core, _discord)
        Window = _window
        Core = _core
        Discord = _discord

        PlayerName = Core.LocalPlayer.Name or "Unknown"

        TierUtility = require(Core.ReplicatedStorage.Shared.TierUtility)
        ItemUtility = require(Core.ReplicatedStorage.Shared.ItemUtility)
    end

    function m:SendWebhook(_fishId, _fishDetails)
        if not Window:GetConfigValue("EnableDiscordWebhook") then
            return
        end

        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        local pingId = Window:GetConfigValue("DiscordPingID") or ""
        if url == "" then
            warn("Webhook:SendWebhook - Webhook URL not set")
            return
        end

        local minRarity = Window:GetConfigValue("NotificationMinRarity") or 0
        if minRarity == 0 then
            warn("Webhook:SendWebhook - Minimum rarity not set")
            return
        end

        local fishData = ItemUtility.GetItemDataFromItemType("Fishes", _fishId)
        if not fishData or not fishData.Data then
            return
        end

        local tierIndex = fishData.Data.Tier or -999999999999
        if tierIndex < minRarity then
            return
        end

        local tierDetail = TierUtility:GetTier(tierIndex)
        local rarity = tierDetail and tierDetail.Name or "Unknown"
        local weight = 0
        local mutations = {}

        for k, v in pairs(_fishDetails or {}) do
            if k == "Weight" then
                weight = v
            elseif k == "Shiny" and v == true then
                table.insert(mutations, "Shiny")
            elseif k == "VariantId" then
                table.insert(mutations, v)
            end
        end

        local mutationsString = #mutations > 0 and table.concat(mutations, ", ") or "None"

        local message = {
            content = pingId ~= "" and ("<@"..pingId..">") or nil,
            embeds = {{
                title = "**EzFish-It**",
                type = 'rich',
                color = tonumber("0xfa0c0c"),
                fields = {
                    {
                        name = '**Profile : ** \n',
                        value = '> Username : ||'..PlayerName.."||",
                        inline = false
                    },
                    {
                        name = '**You have caught a fish!**',
                        value = '> Fish Name: ``'..(fishData.Data.Name or "N/A")..'``'..
                                '\n> Rarity: ``'..(rarity or "N/A")..'``'..
                                '\n> Weight: ``'..(tostring(weight).." KG" or 'N/A')..'``'..
                                '\n> Mutation: ``'..mutationsString..'``',
                        inline = false
                    }
                }
            }}
        }

        Discord:SendMessage(url, message)
    end

    return m
end

-- Module: notification/webhook.lua
EmbeddedModules["notification/webhook.lua"] = function()
    local m = {}

    local Window
    local Core
    local Discord

    local PlayerName

    function m:Init(_window, _core, _discord)
        Window = _window
        Core = _core
        Discord = _discord

        PlayerName = Core.LocalPlayer.Name or "Unknown"
    end

    function m:TestWebhook()
        local url = Window:GetConfigValue("DiscordWebhookURL") or ""
        local pingId = Window:GetConfigValue("DiscordPingID") or ""
        if url == "" then
            return
        end

        local message = {
            content = pingId ~= "" and ("<@"..pingId..">") or nil,
            embeds = {{
                title = "**EzFish-It**",
                type = 'rich',
                color = tonumber("0x00FF00"),
                fields = {{
                    name = '**Profile : ** \n',
                    value = '> Username : ||'..PlayerName.."||",
                    inline = false
                }, {
                    name = '**Notification Test**',
                    value = '> This is a test notification from EzFish-It.',
                    inline = false
                }}
            }}
        }

        Discord:SendMessage(url, message)
    end

    return m
end

-- Module: misc/disable.lua
EmbeddedModules["misc/disable.lua"] = function()
    local m = {}

    local Window
    local Core

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        self:DisableCatchFishAnimation()
        self:DisablePlayerName()
    end

    function m:DisableCatchFishAnimation()
        local isDisabled = Window:GetConfigValue("DisableCatchFishAnimation") or false
        local notification = Core.LocalPlayer.PlayerGui["Small Notification"].Display

        notification.Visible = not isDisabled
    end

    function m:DisablePlayerName()
        local isDisabled = Window:GetConfigValue("DisablePlayerName") or false
        Core:GetHumanoidRootPart().Overhead.Content.Header.Visible = not isDisabled
    end

    return m
end

-- Module: misc/ui.lua
EmbeddedModules["misc/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Disable

    function m:Init(_window, _core, _disable)
        Window = _window
        Core = _core
        Disable = _disable

        local tab = Window:AddTab({
            Name = "Misc",
            Icon = "🛠️",
        })

        self:DisableSection(tab)
        self:ServerSection(tab)
    end

    function m:DisableSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Remove",
            Icon = "❌",
            Default = false,
        })

        accordion:AddToggle({
            Name = "Remove Catch Fish Animation 🎣",
            Default = false,
            Flag = "DisableCatchFishAnimation",
            Callback = function(value)
                Disable:DisableCatchFishAnimation()
            end
        })

        accordion:AddToggle({
            Name = "Remove Player Name",
            Default = false,
            Flag = "DisablePlayerName",
            Callback = function(value)
                Disable:DisablePlayerName()
            end
        })
    end

    function m:ServerSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Server",
            Icon = "🌐",
            Default = false,
        })

        accordion:AddButton({Text = "Rejoin Server 🔄", Callback = function()
            Core:Rejoin()
        end})

        accordion:AddButton({Text = "Hop Server 🚀", Callback = function()
            Core:HopServer()
        end})
    end

    return m
end

-- Module: teleport/npc.lua
EmbeddedModules["teleport/npc.lua"] = function()
    local m = {}

    local Window
    local Core

    function m:Init(_window, _core)
        Window = _window
        Core = _core
    end

    function m:ListNPCRepository()
        local listNpc = {}

        for _, npc in pairs(Core.ReplicatedStorage.NPC:GetChildren()) do
            if npc:IsA("Model") then
                local npcRoot = npc:WaitForChild("HumanoidRootPart")
                local forward = npcRoot.CFrame.LookVector

                -- Adjust target position to be in front of the NPC
                local targetPos = npcRoot.Position + (forward * 5)
                table.insert(listNpc, {
                    Name = npc.Name,
                    Position = CFrame.lookAt(targetPos, npcRoot.Position),
                })
            end
        end

        return listNpc
    end

    function m:FindNPCByName(_name)
        local listNpc = self:ListNPCRepository()
        for _, npc in pairs(listNpc) do
            if npc.Name == _name then
                return npc
            end
        end

        return nil
    end

    return m
end

-- Module: ../module/discord.lua
EmbeddedModules["../module/discord.lua"] = function()
    local m = {}
    local HttpService = game:GetService("HttpService")

    function m:SendMessage(webhookUrl, data)
        -- Mencari fungsi request yang tersedia dari berbagai executor
        local requestFunction = request or
                               (syn and syn.request) or
                               (http and http.request) or
                               (fluxus and fluxus.request) or
                               http_request

        -- Jika tidak ada fungsi request yang tersedia, keluar dari fungsi
        if not requestFunction then
            return
        end

        -- Mengubah data menjadi format JSON
        local jsonData = HttpService:JSONEncode(data)

        -- Menyiapkan headers untuk request
        local headers = {
            ['Content-Type'] = "application/json"
        }

        -- Mengirim POST request ke webhook
        local success, err = pcall(function()
            task.spawn(requestFunction, {
                Url = webhookUrl,
                Body = jsonData,
                Method = 'POST',
                Headers = headers
            })
        end)

        if success then
            print("Discord webhook sent successfully.")
        else
            warn("Failed to send Discord webhook:", err)
        end
    end

    return m

end

-- Module: farm/fishing.lua
EmbeddedModules["farm/fishing.lua"] = function()
    local m = {}

    local Window
    local Core

    local Camera
    local UserInputService
    local FishingController
    local Net
    local Signal
    local GuiControl
    local ChargeFishingRodRemote
    local FishingCompletedEvent
    local ClickHook
    local Replion
    local Constants
    local RaycastUtility
    local RequestFishingMinigameStartedRemote
    local CancelFishingInputsRemote
    local PlayerStatsUtility 
    local EquipToolFromHotbar
    local ItemUtility

    local MinigameProgressSignal
    local FishCaughtConnection
    local FishingMinigameChangedConnection
    local TextEffectConnection
    local DataReplion
    local IsMinigameActive = false
    local IsFishingActive = false
    local LastFishingActivityTime = 0

    local CurrentMinigameData = nil

    function m:Init(_window, _core)
        Window = _window
        Core = _core

        Camera = Core.Workspace.CurrentCamera
        FishingController = require(Core.ReplicatedStorage.Controllers.FishingController)
        Constants = require(Core.ReplicatedStorage.Shared.Constants)
        GuiControl = require(Core.ReplicatedStorage.Modules.GuiControl)
        RaycastUtility = require(Core.ReplicatedStorage.Shared.RaycastUtility)
        Net = require(Core.ReplicatedStorage.Packages.Net)
        Signal = require(Core.ReplicatedStorage.Packages.Signal)
        Replion = require(Core.ReplicatedStorage.Packages.Replion)
        PlayerStatsUtility = require(Core.ReplicatedStorage.Shared.PlayerStatsUtility)
        ItemUtility = require(Core.ReplicatedStorage.Shared.ItemUtility)

        UserInputService = game:GetService("UserInputService")
        ClickHook = GuiControl:Hook("Click")
        MinigameProgressSignal = Signal.new()
        DataReplion = Replion.Client:WaitReplion("Data")

        ChargeFishingRodRemote = Net:RemoteFunction("ChargeFishingRod")
        FishingCompletedEvent = Net:RemoteEvent("FishingCompleted")
        RequestFishingMinigameStartedRemote = Net:RemoteFunction("RequestFishingMinigameStarted")
        CancelFishingInputsRemote = Net:RemoteFunction("CancelFishingInputs")
        EquipToolFromHotbar = Net:RemoteEvent("EquipToolFromHotbar")

        self:CreateConnections()

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoFishing")
            end, 
            function()
                self:StartAutoFishing()
            end
        )

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoInstantCatch")
            end, 
            function()
                self:StartAutoCharge()
            end
        )
    end


    function m:IsMaxInventory()
        if DataReplion:GetExpect("EquippedType") ~= "Fishing Rods" then
            warn("No fishing rod equipped!")
            IsFishingActive = false
            return
        end
        return Constants:CountInventorySize(DataReplion) >= Constants.MaxInventorySize
    end

    function m:isRodEquipped()
        local equippedId = DataReplion:GetExpect("EquippedId")
        local autoEquip = Window:GetConfigValue("AutoEquipFishingRod") or false

        if not equippedId then
            warn("No item is currently equipped.")
            return false
        end

        local inventoryItem = PlayerStatsUtility:GetItemFromInventory(DataReplion, function(item)
            return item.UUID == equippedId
        end)

        if not inventoryItem then
            warn("Equipped item not found in inventory.")
            return false
        end

        local equippedItemData = ItemUtility:GetItemData(inventoryItem.Id)

    	if equippedItemData and equippedItemData.Data.Type == "Fishing Rods" then
            return true
    	end
        if autoEquip then
            EquipToolFromHotbar:FireServer(1)
            return true
        end

        warn("Equipped item is not a fishing rod.")
        return true
    end

    function m:CalculateCastPower()
        local isAutoPerfect = Window:GetConfigValue("AutoPerfectCast") or true
        local minCastPower = 0.5

        if isAutoPerfect then
            minCastPower = 0.95
        end

        -- Generate a random number between minCastPower and 0.9999
        local castPower = math.random() * (0.9999 - minCastPower) + minCastPower
        return castPower
    end

    function m:GetElapsedFromPower(seedTime, castPower)
        local frequency = Random.new(seedTime):NextInteger(4, 10)

    	castPower = math.clamp(castPower, 0, 1)

    	if castPower == 1 then
    		return math.pi / frequency
    	elseif castPower == 0 then
    		return 0
    	end

    	local theta = math.asin(1 - 2 * castPower)
    	local elapsed = (theta - math.pi / 2) / frequency

    	if elapsed < 0 then
    		elapsed = elapsed + (2 * math.pi) / frequency
    	end

    	return elapsed
    end

    function m:GetElapsedFromPowerV2(seedTime, castPower)
        castPower = math.clamp(castPower or 0, 0, 1)

        local frequency = Random.new(seedTime):NextNumber(4, 10)

        if castPower >= 1 then
            local elapsedPeak = math.pi / frequency
            return elapsedPeak, seedTime + elapsedPeak
        end

        if castPower <= 0 then
            return 0, seedTime
        end

        local sinArg = 1 - 2 * castPower

        if sinArg > 1 then sinArg = 1 end
        if sinArg < -1 then sinArg = -1 end

        local theta = math.asin(sinArg)

        local baseElapsed = (theta - (math.pi / 2)) / frequency

        if baseElapsed < 0 then
            baseElapsed = baseElapsed + (2 * math.pi) / frequency
        end

        local timeAtPower = seedTime + baseElapsed
        return baseElapsed, timeAtPower
    end

    function m:GetIsFishingActive()
        if tick() - LastFishingActivityTime > 3 then
            IsFishingActive = false
        end
        return IsFishingActive
    end

    function m:SetIsFishingActive(value)
        if value then
            LastFishingActivityTime = tick()
        end
        IsFishingActive = value
    end

    function m:CreateConnections()
        if not TextEffectConnection then
            TextEffectConnection = Net:RemoteEvent("ReplicateTextEffect").OnClientEvent:Connect(function(data)
                local localPlayerCharacter = Core:GetCharacter()
                if not localPlayerCharacter then return end

                local attachTo = data.TextData and data.TextData.AttachTo
                local container = data.Container

                if attachTo ~= localPlayerCharacter.Head and container ~= localPlayerCharacter.Head then
                    return
                end

                if not CurrentMinigameData then
                    warn("No current minigame data available for text effect.")
                    return
                end

                local clickProgress = 0
                while clickProgress < 1 do
                    task.wait(0.25)
                    print("Clicking for fishing...", CurrentMinigameData.FishingClickPower)
                    self:SetIsFishingActive(true)
                    clickProgress = clickProgress + (CurrentMinigameData.FishingClickPower)
                end

                FishingCompletedEvent:FireServer()
            end)
        end

        if not FishCaughtConnection then
            FishCaughtConnection = Net:RemoteEvent("ObtainedNewFishNotification").OnClientEvent:Connect(function(...)
                -- IsMinigameActive = false
                if not IsFishingActive then
                    return
                end
                self:SetIsFishingActive(false)
                self:StartAutoFishing()
            end)
        end
    end

    function m:GetRayCastPosition()
        local rootPart = Core:GetHumanoidRootPart()
        if not rootPart then
            warn("HumanoidRootPart not found!")
            self:SetIsFishingActive(false)
            return
        end
        local rootCFrame = rootPart.CFrame
        local castPosition = rootCFrame + rootCFrame.LookVector * 12
        local rayOrigin = castPosition.Position
        local rayDirection = Vector3.new(0, -Constants.FishingDistance, 0)
        local filteredTargets = RaycastUtility:getFilteredTargets(Core.LocalPlayer)

        local raycastParams = RaycastParams.new()
        raycastParams.IgnoreWater = true
        raycastParams.RespectCanCollide = false
        raycastParams.FilterType = Enum.RaycastFilterType.Exclude
        raycastParams.FilterDescendantsInstances = filteredTargets

        local raycastResult = workspace:Spherecast(rayOrigin, 2, rayDirection, raycastParams)
        return raycastResult
    end

    function m:StartAutoFishing()
        if not Window:GetConfigValue("AutoFishing") or self:GetIsFishingActive() then
            return
        end

        self:CreateConnections()
        local autoEquip = Window:GetConfigValue("AutoEquipFishingRod") or false

        if autoEquip and not self:isRodEquipped() then
            EquipToolFromHotbar:FireServer(1)
            return
        end

        if not self:isRodEquipped() then
            warn("No fishing rod equipped!")
            self:SetIsFishingActive(false)
            return
        end

        local autoSell = Window:GetConfigValue("AutoSellFish") or false
        if self:IsMaxInventory() and autoSell == true then
            FishingController:NoInventorySpace()
        end

        if self:IsMaxInventory() then
            warn("Inventory full, cannot fish!")
            self:SetIsFishingActive(false)
            return        
        end

        local raycastResult = self:GetRayCastPosition()
        if not raycastResult or not raycastResult.Instance then
            warn("Failed rod cast!")

            self:SetIsFishingActive(false)
            return
        end


        while Window:GetConfigValue("AutoFishing") and Core.IsWindowOpen do
            self:SetIsFishingActive(true)
            local chargeTime = workspace:GetServerTimeNow()
            local castPower = self:CalculateCastPower()
            local delayCast = self:GetElapsedFromPower(chargeTime, castPower)
            ChargeFishingRodRemote:InvokeServer(chargeTime - delayCast)

            if Window:GetConfigValue("AutoPerfectCast") then
                -- task.wait(delayCast)
                task.wait(0.2)
            end

            local startTime = workspace:GetServerTimeNow()
            local success, minigameData = RequestFishingMinigameStartedRemote:InvokeServer(raycastResult.Position.Y, castPower, startTime)
            if success then
                CurrentMinigameData = minigameData
                break
            end
            CancelFishingInputsRemote:InvokeServer()
        end
    end

    function m:StopAutoFishing()
        IsMinigameActive = false
        self:SetIsFishingActive(false)

        CancelFishingInputsRemote:InvokeServer()

        if FishCaughtConnection then
            FishCaughtConnection:Disconnect()
            FishCaughtConnection = nil
        end

        if TextEffectConnection then
            TextEffectConnection:Disconnect()
            TextEffectConnection = nil
        end
    end

    function m:StartAutoCharge()
        if not Window:GetConfigValue("AutoInstantCatch") or self:GetIsFishingActive() then
            return
        end

        self:CreateConnections()

        local autoEquip = Window:GetConfigValue("AutoEquipFishingRod") or false
        if autoEquip and not self:isRodEquipped() then
            EquipToolFromHotbar:FireServer(1)
            return
        end

        if not self:isRodEquipped() then
            warn("No fishing rod equipped!")
            self:SetIsFishingActive(false)
            return
        end

        local raycastResult = self:GetRayCastPosition()
        while Window:GetConfigValue("AutoInstantCatch") and Core.IsWindowOpen do
            self:SetIsFishingActive(true)
            if not raycastResult or not raycastResult.Instance then
                task.wait(0.1)
                raycastResult = self:GetRayCastPosition()
                continue
            end

            coroutine.wrap(function()
                CancelFishingInputsRemote:InvokeServer()

                while Window:GetConfigValue("AutoInstantCatch") and Core.IsWindowOpen do
                local castBuffer = math.max(Window:GetConfigValue("CastDelayBuffer") or 0.2, 0.05)
                local chargeTime = workspace:GetServerTimeNow()
                local castPower = self:CalculateCastPower()
                -- local castPower = Constants:GetPower(startTime)
                local delayCast = self:GetElapsedFromPower(chargeTime, castPower)
                ChargeFishingRodRemote:InvokeServer(chargeTime)

                -- [[ START: FIX ]] --
                
                -- REMOVED: The incorrect 'if Window:GetConfigValue("AutoPerfectCast")' block
                
                -- ADDED: The correct wait. This tells the script to wait for the
                -- calculated duration ('delayCast') before trying to start the minigame.
                -- This simulates a real player holding down the button.
                task.wait(delayCast + castBuffer)

                -- [[ END: FIX ]] --

                local startTime = workspace:GetServerTimeNow()
                local success, minigameData = RequestFishingMinigameStartedRemote:InvokeServer(raycastResult.Position.Y, castPower, startTime)
                if success then
                    CurrentMinigameData = minigameData
                    break
                else
                    CancelFishingInputsRemote:InvokeServer()
                end
            end
            end)()

            local delayRetry = math.max(Window:GetConfigValue("AutoInstantCatchDelay") or 1.30, 0.1)

            -- if Window:GetConfigValue("AutoPerfectCast") then
            --     delayRetry = delayCast + delayRetry
            -- end
            print("Waiting after cast for perfect catch:", delayRetry)
            task.wait(delayRetry)
        end

        self:StopAutoFishing()
    end

    return m
end

-- Module: farm/inventory.lua
EmbeddedModules["farm/inventory.lua"] = function()
    local m = {}

    local Window
    local Core
    local Webhook

    local TierUtility
    local ItemUtility
    local Replion
    local DataReplion
    local Net

    local FishCaughtConnection
    local FishCount = 0

    m.ListFish = {}

    function m:Init(_window, _core, _webhook)
        Window = _window
        Core = _core
        Webhook = _webhook

        TierUtility = require(Core.ReplicatedStorage.Shared.TierUtility)
        ItemUtility = require(Core.ReplicatedStorage.Shared.ItemUtility)
        Replion = require(Core.ReplicatedStorage.Packages.Replion)
        Net = require(Core.ReplicatedStorage.Packages.Net)

        DataReplion = Replion.Client:WaitReplion("Data")

        self.ListFish = self:ListFishItems()

        if Window:GetConfigValue("AutoSellFish") or Window:GetConfigValue("AutoFavoriteFish") then
    		self:CreateConnections()
    	end
    end

    function m:ListFishItems()
        local listFishs = {}
        local fishData = ItemUtility:GetFishes() or {}

        for fishName, fishInfo in pairs(fishData) do
            if not fishInfo.Data then
                continue
            end

            local tierIndex = fishInfo.Data.Tier or 100
            local tierDetail = TierUtility:GetTier(tierIndex)

            table.insert(listFishs, {
                Name = fishInfo.Data.Name or "Unknown",
                SellPrice = fishInfo.SellPrice or 0,
                Rarity = tierDetail and tierDetail.Name or "Unknown",
                RarityIndex = tierIndex,
            })
        end

        table.sort(listFishs, function(a, b)
            if a.RarityIndex == b.RarityIndex then
                return a.Name < b.Name
            else
                return a.RarityIndex < b.RarityIndex
            end
        end)

        return listFishs
    end

    function m:FindFishItemByName(fishName)
        for _, fishItem in pairs(self.ListFish) do
            if fishItem.Name == fishName then
                return fishItem
            end
        end

        return nil
    end

    function m:CreateConnections()
    	if FishCaughtConnection then
    		return
    	end

    	FishCaughtConnection = Net:RemoteEvent("ObtainedNewFishNotification").OnClientEvent:Connect(function(fishId, fishMetadata, fishInventoryItem)
            coroutine.wrap(function()
                self:InventoryController(fishId, fishMetadata, fishInventoryItem)
            end)()
    	end)
    end

    function m:RemoveConnections()
    	if FishCaughtConnection then
    		FishCaughtConnection:Disconnect()
    		FishCaughtConnection = nil
    	end
    end

    function m:ListInventoryFishs()
        local inventory = DataReplion:GetExpect({ "Inventory" })
        local items = inventory and inventory["Items"] or {}
        local fishItems = {}

        for _, item in pairs(items) do
            local itemData = ItemUtility.GetItemDataFromItemType("Fishes", item.Id)
            if not item.Metadata then
                continue
            end

            if not itemData or not itemData.Data then
                continue
            end

            if  itemData.Data.Type ~= "Fishes" then
                continue
            end

            local tierIndex = itemData.Data.Tier or 100
            local tierDetail = TierUtility:GetTier(tierIndex)

            table.insert(fishItems, {
                UUID = item.UUID,
                Id = item.Id,
                Name = itemData.Data.Name or "Unknown",
                Favorited = item.Favorited or false,
                Metadata = item.Metadata or {},
                Type = itemData.Data.Type or "Unknown",
                Rarity = tierDetail and tierDetail.Name or "Unknown",
                RarityIndex = tierIndex,
            })
        end

        return fishItems
    end

    function m:InventoryController(fishId, fishMetadata, fishInventoryItem)
        if Window:GetConfigValue("EnableDiscordWebhook") then
            coroutine.wrap(function()
                Webhook:SendWebhook(fishId, fishMetadata)
            end)()
        end

        if Window:GetConfigValue("AutoFavoriteFish") then
            self:FavoriteFish(fishInventoryItem.InventoryItem)
        end

        if Window:GetConfigValue("AutoSellFish") then
            FishCount = FishCount + 1
            local autoSellThreshold = Window:GetConfigValue("AutoSellFishCount") or 50

            if FishCount <= autoSellThreshold then
                return
            end

            -- Count fish from inventory to ensure we have enough to sell
            local inventoryFishCount = 0
            for _, fishItem in pairs(self:ListInventoryFishs()) do
                if fishItem.Favorited then
                    continue
                end

                inventoryFishCount = inventoryFishCount + 1
            end

            if inventoryFishCount < FishCount then
                FishCount = inventoryFishCount
                return
            end

            self:SellAllFish()
            FishCount = 0
        end
    end

    function m:FavoriteFish(fishInventoryItem)
        if not fishInventoryItem then
            return
        end
        local favoriteFishName = Window:GetConfigValue("FavoriteFishName") or {}
        local minRarityToFavorite = Window:GetConfigValue("FavoriteMinRarityFish") or 9999999999999999

        local fishData = ItemUtility.GetItemDataFromItemType("Fishes", fishInventoryItem.Id)
        if not fishData or not fishData.Data then
            warn("Inventory:FavoriteFish - Unable to find fish data for ID:", fishInventoryItem.Id)
            return
        end

        local fishName = fishData.Data.Name or "Unknown"
        local rarityIndex = fishData.Data.Tier or -999999999999

        if table.find(favoriteFishName, fishName) then
            self:FavoriteItemByUUID(fishInventoryItem.UUID)
            return
        end

        if rarityIndex > minRarityToFavorite then
            self:FavoriteItemByUUID(fishInventoryItem.UUID)
            return
        end

        return
    end

    function m:FavoriteItemByUUID(itemUUID)
        if not itemUUID then
            return
        end

        local success = Net:RemoteEvent("FavoriteItem"):FireServer(itemUUID)
        if success then
            print("Favorited item with UUID:", itemUUID)
        else
            warn("Failed to favorite item with UUID:", itemUUID)
        end
    end

    function m:SellAllFish()	
    	local sellSuccess = Net:RemoteFunction("SellAllItems"):InvokeServer()
    	if not sellSuccess then
    		warn("Failed to sell all fish.")
    	end
    end

    return m
end

-- Module: farm/ui.lua
EmbeddedModules["farm/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Fishing
    local Inventory

    local TierData

    function m:Init(_window, _core, _fishing, _inventory)
        Window = _window
        Core = _core
        Fishing = _fishing
        Inventory = _inventory

        local tab = Window:AddTab({
            Name = "Farm",
            Icon = "💵",
        })

        TierData = require(Core.ReplicatedStorage.Tiers)

        self:FishingSection(tab)
        self:SellSection(tab)
        self:FavoriteSection(tab)
    end

    function m:FishingSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Fishing",
            Icon = "🎣",
            Default = false,
        })

        accordion:AddToggle({
            Name = "Auto Equip Fishing Rod 🎣",
            Default = false,
            Flag = "AutoEquipFishingRod",
        })

        accordion:AddToggle({
            Name = "Auto Perfect Cast 🎯",
            Default = false,
            Flag = "AutoPerfectCast",
        })

        accordion:AddToggle({
            Name = "Auto Fishing 🎣",
            Default = false,
            Flag = "AutoFishing",
            Callback = function(value)
                if value then
                    Fishing:StartAutoFishing()
                else
                    Fishing:StopAutoFishing()
                end
            end
        })

        accordion:AddSeparator()

        accordion:AddNumberBox({
            Name = "Delay between casts ⛵",
            Placeholder = "Delay between casts...",
            Default = 1.8,
            Min = 0.1,
            Max = 20.0,
            Increment = 0.01,
            Decimals = 2,
            Flag = "AutoInstantCatchDelay",
        })

        accordion:AddToggle({
            Name = "Auto Instant Catch 🐟",
            Default = false,    
            Flag = "AutoInstantCatch",
            Callback = function(value)
                if value then
                    Fishing:StartAutoCharge()
                else
                    Fishing:StopAutoFishing()
                end
            end
        })

                accordion:AddNumberBox({
            Name = "Delay cast ppower ⛵",
            Placeholder = "Delay cast power...",
            Default = 0.2,
            Min = 0.05,
            Max = 10,
            Increment = 0.01,
            Decimals = 2,
            Flag = "CastDelayBuffer",
        })
    end

    function m:SellSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Sell",
            Icon = "💰",
            Default = false,
        })

        accordion:AddNumberBox({
            Name = "Auto Sell Fish Count",
            Placeholder = "Number of fish to auto sell at...",
            Default = 50,
            Min = 1,
            Max = 1000,
            Increment = 1,
            Decimals = 0,
            Flag = "AutoSellFishCount",
        })

        accordion:AddToggle({
            Name = "Automatically sell all fish",
            Default = false,
            Flag = "AutoSellFish",
        })

        accordion:AddButton({
            Name = "Sell All Fish Now",
            Variant = "warning",
            Callback = function()
                Inventory:SellAllFish()
            end
        })
    end

    function m:FavoriteSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Favorite",
            Icon = "⭐",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Minimum Rarity to Favorite",
            Options = {"Loading ..."},
            Placeholder = "Select Minimum Rarity",
            MultiSelect = false,
            Flag = "FavoriteMinRarityFish",
            OnInit = function(api, optionsData)
                local formattedTiers = {}

                for _, tierDetail in pairs(TierData) do
                    table.insert(formattedTiers, {
                        text = tierDetail.Name,
                        value = tierDetail.Tier,
                    })
                end

                optionsData.updateOptions(formattedTiers)
            end,
        })

        accordion:AddSelectBox({
            Name = "Or Fish Name",
            Options = {"Loading ..."},
            Placeholder = "Select Fish Name",
            MultiSelect = true,
            Flag = "FavoriteFishName",
            OnInit = function(api, optionsData)
                local fishData = Inventory.ListFish
                local formattedFish = {}

                for _, fishDetail in pairs(fishData) do
                    table.insert(formattedFish, {
                        text = string.format("[%s] - %s [Base Price: %s]", fishDetail.Rarity, fishDetail.Name, string.format("%0.2f", fishDetail.SellPrice):gsub("%.", ".")),
                        value = fishDetail.Name,
                    })
                end
                optionsData.updateOptions(formattedFish)
            end,
        })

        accordion:AddToggle({
            Name = "Auto Favorite Fish",
            Default = false,
            Flag = "AutoFavoriteFish"
        })

    end

    return m
end

-- Module: teleport/lock.lua
EmbeddedModules["teleport/lock.lua"] = function()
    local m = {}

    local Window
    local Core
    local Player
    local TeleportEvent

    function m:Init(_window, _core, _player, _teleportEvent)
        Window = _window
        Core = _core
        Player = _player
        TeleportEvent = _teleportEvent

        print("Initializing Lock Module...")

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("LockPlayer")
            end, 
            function()
                self:StartLockPlayer()
            end
        )
    end

    function m:StartLockPlayer()
        if not Window:GetConfigValue("LockPlayer") then
            warn("Lock Player is disabled.")
            return
        end

        if TeleportEvent.IsOnEvent then
            warn("Skipping lock position while on event.")
            return
        end

        local configLockPosition = Window:GetConfigValue("LockPlayerPosition")
        local lockAtPosition

        if configLockPosition then
            if typeof(configLockPosition) == "string" then
                local values = string.split(configLockPosition, ",")
                for i, v in ipairs(values) do
                    values[i] = tonumber(v)
                end

                if #values == 3 then
                    lockAtPosition = CFrame.new(Vector3.new(values[1], values[2], values[3]))
                elseif #values == 12 then
                    lockAtPosition = CFrame.new(
                        values[1], values[2], values[3],
                        values[4], values[5], values[6],
                        values[7], values[8], values[9],
                        values[10], values[11], values[12]
                    )
                else
                    warn("Lock position string is invalid.")
                    return
                end
            elseif typeof(configLockPosition) == "Vector3" then
                lockAtPosition = CFrame.new(configLockPosition)
            elseif typeof(configLockPosition) == "CFrame" then
                lockAtPosition = configLockPosition
            else
                warn("Lock position is invalid or not set properly.")
                return
            end
        else
            warn("Lock position is not set.")
            return
        end

        local currentPosition = Player:GetPosition()
        if (currentPosition.Position - lockAtPosition.Position).Magnitude ~= 0 then
            Player:TeleportToPosition(lockAtPosition)
        end
    end

    return m
end

-- Module: teleport/spot.lua
EmbeddedModules["teleport/spot.lua"] = function()
    local m = {}

    local Core

    function m:Init(_core)
        Core = _core
    end

    local FishingSpots = {
        {
            Name = "Ancient Jungle",
            Position = CFrame.new(1836.27014, 3.22775936, -323.472473, 0.209259018, -1.00738291e-07, -0.977860272, -8.14813994e-09, 1, -1.04762783e-07, 0.977860272, 2.98902982e-08, 0.209259018),
        },
        {
            Name = "Coral Reefs",
            Position = CFrame.new(-3119.21997, 2.94513345, 2136.76221, 0.839347124, 6.66862547e-08, -0.543595791, -4.54390552e-08, 1, 5.25153396e-08, 0.543595791, -1.93781204e-08, 0.839347124),
        },
        {
            Name = "Crater Island",
            Position = CFrame.new(1079.42944, 3.05696344, 5087.74902, 0.152732253, 3.38155309e-10, 0.988267601, -6.79443772e-08, 1, 1.0158324e-08, -0.988267601, -6.86987249e-08, 0.152732253),
        },
        {
            Name = "Machine",
            Position = CFrame.new(-1457.8512, 14.7337818, 1843.03955, 0.199816436, -8.31816536e-08, -0.979833364, 1.09653149e-08, 1, -8.26575288e-08, 0.979833364, 5.77215165e-09, 0.199816436),
        },
        {
            Name = "Sacred Temple",
            Position = CFrame.new(1503.81348, -22.1250019, -629.491028, -0.995985448, -1.43146188e-08, -0.0895152986, -1.34328335e-08, 1, -1.04530926e-08, 0.0895152986, -9.20868448e-09, -0.995985448),
        },
        {
            Name = "Sisyphus Statue",
            Position = CFrame.new(-3742.60962, -135.174316, -1013.46899, -0.989471078, -4.82439972e-08, -0.144730732, -5.28477671e-08, 1, 2.79646191e-08, 0.144730732, 3.53188803e-08, -0.989471078),
        },
        {
            Name = "Treasure Room",
            Position = CFrame.new(-3597.65625, -279.073761, -1586.88818, 0.992161453, -7.67678099e-09, -0.124962427, 5.8638383e-09, 1, -1.48757211e-08, 0.124962427, 1.40263579e-08, 0.992161453),
        },
        {
            Name = "Tropical Grove",
            Position = CFrame.new(-2166.33984, 2.84337163, 3639.77661, -0.350484759, 1.65289595e-08, -0.936568439, 2.19230123e-09, 1, 1.68280181e-08, 0.936568439, 3.84472365e-09, -0.350484759),
        },
        {
            Name = "Underground Cellar",
            Position = CFrame.new(2106.68066, -91.1976471, -724.831787, -0.602142394, 1.76590138e-08, -0.79838872, 3.69580135e-08, 1, -5.7553069e-09, 0.79838872, -3.29723733e-08, -0.602142394),
        },
        {
            Name = "Kohana Volcano",
            Position = CFrame.new(-552.865845, 17.2351856, 114.849068, 1, -3.87002039e-08, 1.16584761e-13, 3.87002039e-08, 1, -7.07843171e-08, -1.13845389e-13, 7.07843171e-08, 1),
        },
        {
            Name = "Mount Hallow",
            Position = CFrame.new(2166.75806, 80.541008, 3289.41211, -0.499248028, 7.93332902e-08, 0.866459131, 5.98914767e-08, 1, -5.70512668e-08, -0.866459131, 2.34107826e-08, -0.499248028),
        }
    }

    function m:GetAllFishingSpots()
        local areas = require(Core.ReplicatedStorage.Areas)
        local spots = {}

        for _, spot in pairs(FishingSpots) do
            local areaDetail = areas[spot.Name]

            if not areaDetail then
                warn("Area detail not found for spot:", spot.Name)
                areaDetail = areas["Ocean"]
            end

            table.insert(spots, {
                Name = spot.Name,
                Position = spot.Position,
                BaseLuck = areaDetail and areaDetail.BaseLuck or 0,
                ClickPowerMultiplier = areaDetail and areaDetail.ClickPowerMultiplier or 0,
            })
        end


        return spots
    end

    function m:FindSpotByName(_name)
        for _, spot in pairs(FishingSpots) do
            if spot.Name == _name then
                return spot
            end
        end

        return nil
    end

    return m
end

-- Module: auto/ui.lua
EmbeddedModules["auto/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Events
    local Enchant
    local Trade

    local TierData

    function m:Init(_window, _core, _events, _enchant, _trade)
        Window = _window
        Core = _core
        Events = _events
        Enchant = _enchant
        Trade = _trade

        TierData = require(Core.ReplicatedStorage.Tiers)

        local tab = Window:AddTab({
            Name = "AutoMation",
            Icon = "🤖",
        })

        self:HelloweenSection(tab)
        self:WeatherMachineSection(tab)
        self:EnchantSection(tab)
        self:TradeSection(tab)
    end

    function m:HelloweenSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Halloween",
            Icon = "🎃",
            Default = false,
        })

        accordion:AddToggle({
            Name = "Auto Trick Or Treat 🎃",
            Default = false,
            Flag = "AutoTrickOrTreat",
        })
    end

    function m:WeatherMachineSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Weather Machine",
            Icon = "☁️",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Weather Machine ☁️",
            Options = {"loading ..."},
            Placeholder = "Select Weather Machine",
            MultiSelect = true,
            Flag = "WeatherMachineItem",
            OnInit =  function(api, optionsData)
                local weatherMachines = Events:GetListWeathersMachine() or {}
                local formattedWeathers = {}
                for _, weatherData in pairs(weatherMachines) do
                    table.insert(formattedWeathers, {
                        text = string.format("[%s] %s - %s Coins (%s)", weatherData.Tier, weatherData.Name, tostring(weatherData.Price):reverse():gsub("%d%d%d", "%1."):reverse():gsub("^%.", ""), weatherData.Description),
                        value = weatherData.Name
                    })
                end
                optionsData.updateOptions(formattedWeathers)
            end
        })

        accordion:AddButton({
            Name = "Buy Selected Weather Machine ☁️",
            Callback = function()
                local selectedWeathers = Window:GetConfigValue("WeatherMachineItem") or {}
                for _, weatherName in pairs(selectedWeathers) do
                    Events:BuyWeatherMachine(weatherName)
                end
            end
        })

        accordion:AddToggle({
            Name = "Auto Buy Weather Machine ☁️",
            Default = false,
            Flag = "AutoBuyWeatherMachine",
        })
    end

    function m:EnchantSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Auto Enchant",
            Icon = "✨",
            Default = false,
        })

        accordion:AddLabel("")
        accordion:AddLabel(function()
            local currentRod = Enchant:GetCurrentRodDetails()

            return string.format("Current Rod: %s\nEnchant 1: %s \nEnchant 2: %s", currentRod.Name or "N/A", currentRod.Enchant1 or "None", currentRod.Enchant2 or "None")
        end)
        accordion:AddLabel("")

        accordion:AddSeparator()

        accordion:AddLabel("Enchant 1")
        accordion:AddSelectBox({
            Name = "Select Target Enchant",
            Options = Enchant:GetListEnchant(),
            Placeholder = "Select Enchant...",
            MultiSelect = true,
            Flag = "TargetEnchant1",
            Default = "",
        })

        accordion:AddToggle({
            Name = "Auto Enchant",
            Default = false,
            Flag = "AutoEnchant1",
        })

        accordion:AddSeparator()

        accordion:AddLabel("Enchant 2")
        accordion:AddSelectBox({
            Name = "Select Target Enchant",
            Options = Enchant:GetListEnchant(),
            Placeholder = "Select Enchant...",
            MultiSelect = false,
            Flag = "TargetEnchant2",
            Default = "",
        })

        accordion:AddToggle({
            Name = "Auto Enchant",
            Default = false,
            Flag = "AutoEnchant2",
        })
    end

    function m:TradeSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Auto Trade",
            Icon = "🤝",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Player to Give",
            Options = {"loading ..."},
            Placeholder = "Select Player...",
            MultiSelect = false,
            Flag = "GiveToPlayer",
            OnDropdownOpen = function(currentOptions, updateOptions)
                local players = Core.Players:GetChildren()
                local formattedPlayers = {}

                for _, playerData in pairs(players) do
                    if playerData == Core.LocalPlayer then
                        continue
                    end
                    table.insert(formattedPlayers, {text = playerData.Name, value = playerData.UserId})
                end

                table.sort(formattedPlayers, function(a, b)
                    return a.text < b.text
                end)

                updateOptions(formattedPlayers)
            end
        })

        accordion:AddSelectBox({
            Name = "Select Item to Give",
            Options = {"loading ..."},
            Placeholder = "Select Item...",
            MultiSelect = true,
            Flag = "GiveItem",
            OnInit = function(api, optionsData)
                local itemData = Trade.TradeItems
                local formattedItems = {}

                for _, itemDetail in pairs(itemData) do
                    table.insert(formattedItems, {
                        text = string.format("[%s] - %s [Type: %s]", itemDetail.Rarity, itemDetail.Name, itemDetail.Type),
                        value = itemDetail.Name,
                    })
                end
                optionsData.updateOptions(formattedItems)
            end,
        })

        accordion:AddSelectBox({
            Name = "Or Minimum Rarity to Give",
            Options = {"loading ..."},
            Placeholder = "Select Minimum Rarity",
            MultiSelect = false,
            Flag = "GiveMinRarityItems",
            OnInit = function(api, optionsData)
                local formattedTiers = {}

                for _, tierDetail in pairs(TierData) do
                    table.insert(formattedTiers, {
                        text = tierDetail.Name,
                        value = tierDetail.Tier,
                    })
                end

                optionsData.updateOptions(formattedTiers)
            end,
        })

        accordion:AddToggle({
            Name = "Don't Give Favorite Items",
            Default = false,
            Flag = "DontGiveFavoriteItems",
        })

        accordion:AddToggle({
            Name = "Auto Give Items",
            Default = false,
            Flag = "AutoGiveItems",
            OnToggle = function(value)
                if value then
                    Trade:StartAutoGive()
                end
            end,
        })

        accordion:AddSeparator()

        accordion:AddToggle({
            Name = "Auto Accept Incoming Trades",
            Default = false,
            Flag = "AutoAcceptTrades",
        })
    end

    return m
end

-- Module: https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua
EmbeddedModules["https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua"] = function()
    -- Bundled Lua Script
    -- Generated by Lua Bundler
    -- https://github.com/alfin-efendy/lua-bundler

    local EmbeddedModules = {}

    -- Module: components/tab
    EmbeddedModules["components/tab"] = function()
        --[[
        	Tab Component
        	EzUI Library - Modular Component

        	Creates a tab with icon, title, and content
        ]]
        -- Component modules (will be loaded by Window)

        local Tab = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator
        local Accordion

        -- Initialize component modules
        function Tab:Init(_colors, _accordion, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Accordion = _accordion
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Tab:Create(config)
        	local tabName = config.Name or config.Title or "New Tab"
        	local tabIcon = config.Icon or nil
        	local tabVisible = config.Visible ~= nil and config.Visible or true
        	local tabCallback = config.Callback or nil
        	local tabScrollFrame = config.TabScrollFrame
        	local tabContents = config.TabContents
        	local scrollFrame = config.ScrollFrame
        	local updateCanvasSize = config.UpdateCanvasSize

        	-- Create tab content frame for this specific tab
        	local tabContent = Instance.new("Frame")
        	tabContent.Size = UDim2.new(1, 0, 1, 0)
        	tabContent.Position = UDim2.new(0, 0, 0, 0)
        	tabContent.BackgroundTransparency = 1
        	tabContent.Visible = false
        	tabContent.ClipsDescendants = false -- Allow SelectBox dropdowns to show
        	tabContent.ZIndex = 2 -- Above scroll frame
        	tabContent.Parent = scrollFrame

        	-- Store tab content in the tabContents table if it exists
        	if tabContents then
        		tabContents[tabName] = tabContent
        	end

        	-- Tab button (container)
        	local tabBtn = Instance.new("TextButton")
        	tabBtn.Size = UDim2.new(1, -10, 0, 36)
        	tabBtn.BackgroundTransparency = 1
        	tabBtn.Text = ""
        	tabBtn.BorderSizePixel = 0
        	tabBtn.ZIndex = 4
        	tabBtn.Visible = tabVisible
        	tabBtn.Parent = tabScrollFrame

        	-- Rounded corners for tab button (only right side)
        	local tabCorner = Instance.new("UICorner")
        	tabCorner.CornerRadius = UDim.new(0, 6)
        	tabCorner.Parent = tabBtn

        	-- Active indicator (left border with rounded right side)
        	local activeIndicator = Instance.new("Frame")
        	activeIndicator.Size = UDim2.new(0, 4, 0, 24)
        	activeIndicator.Position = UDim2.new(0, 0, 0.5, -12)
        	activeIndicator.BackgroundColor3 = Colors.Accent.Primary
        	activeIndicator.BorderSizePixel = 0
        	activeIndicator.ZIndex = 6
        	activeIndicator.Visible = false
        	activeIndicator.Parent = tabBtn

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 4)
        	indicatorCorner.Parent = activeIndicator

        	-- Icon label (left aligned)
        	local iconLabel = Instance.new("TextLabel")
        	iconLabel.Size = UDim2.new(0, 30, 1, 0)
        	iconLabel.Position = UDim2.new(0, 8, 0, 0)
        	iconLabel.BackgroundTransparency = 1
        	iconLabel.Text = tabIcon or ""
        	iconLabel.TextColor3 = Colors.Tab.TextInactive
        	iconLabel.Font = Enum.Font.GothamBold
        	iconLabel.TextSize = 16
        	iconLabel.TextXAlignment = Enum.TextXAlignment.Left
        	iconLabel.ZIndex = 5
        	iconLabel.Parent = tabBtn

        	-- Title label (right aligned)
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = tabName
        	titleLabel.TextColor3 = Colors.Tab.TextInactive
        	titleLabel.Font = Enum.Font.GothamBold
        	titleLabel.TextSize = 14
        	titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        	titleLabel.ZIndex = 5
        	titleLabel.Parent = tabBtn

        	-- Function to update title alignment based on icon presence
        	local function updateTitleAlignment()
        		if tabIcon and tabIcon ~= "" then
        			-- Icon on left, title on right
        			titleLabel.Size = UDim2.new(1, -45, 1, 0)
        			titleLabel.Position = UDim2.new(0, 38, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Right
        			iconLabel.Visible = true
        		else
        			-- No icon, title centered
        			titleLabel.Size = UDim2.new(1, -16, 1, 0)
        			titleLabel.Position = UDim2.new(0, 8, 0, 0)
        			titleLabel.TextXAlignment = Enum.TextXAlignment.Center
        			iconLabel.Visible = false
        		end
        	end

        	-- Initial alignment setup
        	updateTitleAlignment()

        	-- Track current Y position for components (reduced top spacing)
        	local currentY = 5

        	-- Helper function to update canvas size after adding components
        	local function updateTabCanvasSize()
        		if updateCanvasSize and tabContent.Visible then
        			-- Only update if this tab is currently active
        			task.spawn(function()
        				task.wait() -- Wait for component to be fully added
        				updateCanvasSize()
        			end)
        		end
        	end

        	-- Tab API
        	local tabAPI = {
        		Button = tabBtn,
        		Content = tabContent,
        		Name = tabName,
        	}

        	function tabAPI:SetIcon(newIcon)
        		tabIcon = newIcon
        		iconLabel.Text = newIcon or ""
        		updateTitleAlignment()
        	end

        	function tabAPI:SetTitle(newTitle)
        		tabName = newTitle
        		titleLabel.Text = newTitle
        	end

        	function tabAPI:SetVisible(visible)
        		tabBtn.Visible = visible
        	end

        	function tabAPI:Show()
        		tabContent.Visible = true
        	end

        	function tabAPI:Hide()
        		tabContent.Visible = false
        	end

        	function tabAPI:IsVisible()
        		return tabContent.Visible
        	end

        	function tabAPI:Select()
        		tabContent.Visible = true
        		tabBtn.BackgroundTransparency = 0
        		tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		activeIndicator.Visible = true
        		titleLabel.TextColor3 = Colors.Text.Primary
        		iconLabel.TextColor3 = Colors.Text.Primary

        		-- Update canvas size when tab becomes active
        		if updateCanvasSize then
        			-- Wait a frame to ensure visibility changes are processed
        			task.spawn(function()
        				task.wait()
        				updateCanvasSize()
        			end)
        		end

        		if tabCallback then
        			tabCallback()
        		end
        	end

        	function tabAPI:Deselect()
        		tabContent.Visible = false
        		tabBtn.BackgroundTransparency = 1
        		activeIndicator.Visible = false
        		titleLabel.TextColor3 = Colors.Tab.TextInactive
        		iconLabel.TextColor3 = Colors.Tab.TextInactive
        	end

        	-- Hover effects
        	tabBtn.MouseEnter:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundHover
        		end
        	end)

        	tabBtn.MouseLeave:Connect(function()
        		if not tabContent.Visible then
        			tabBtn.BackgroundTransparency = 1
        		else
        			tabBtn.BackgroundTransparency = 0
        			tabBtn.BackgroundColor3 = Colors.Tab.BackgroundActive
        		end
        	end)

        	-- Add Button Component
        	function tabAPI:AddButton(buttonConfig)
        		if not Button then
        			return nil
        		end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = tabContent
        		btnConfig.Y = currentY
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return buttonAPI
        	end

        	-- Add Toggle Component
        	function tabAPI:AddToggle(toggleConfig)
        		if not Toggle then
        			return nil
        		end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = tabContent
        		toggleConfig.Y = currentY
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return toggleAPI
        	end

        	-- Add TextBox Component
        	function tabAPI:AddTextBox(textboxConfig)
        		if not TextBox then
        			return nil
        		end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = tabContent
        		textboxConfig.Y = currentY
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)

        		-- Calculate height based on TextBox configuration
        		local hasTitle = (textboxConfig.Name and textboxConfig.Name ~= "") or (textboxConfig.Title and textboxConfig.Title ~= "")
        		local multiline = textboxConfig.Multiline or false
        		local labelHeight = hasTitle and 18 or 0
        		local inputHeight = multiline and 80 or 30
        		local spacing = hasTitle and 2 or 0
        		local totalHeight = labelHeight + inputHeight + spacing + 5 -- +5 for component spacing

        		currentY = currentY + totalHeight
        		updateTabCanvasSize()

        		return textboxAPI
        	end

        	-- Add NumberBox Component
        	function tabAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then
        			return nil
        		end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = tabContent
        		numberboxConfig.Y = currentY
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		currentY = currentY + 35
        		updateTabCanvasSize()

        		return numberboxAPI
        	end

        	-- Add SelectBox Component
        	function tabAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then
        			return nil
        		end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = tabContent
        		selectboxConfig.Y = currentY
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		currentY = currentY + 30
        		updateTabCanvasSize()

        		return selectboxAPI
        	end

        	-- Add Label Component
        	function tabAPI:AddLabel(labelConfig)
        		if not Label then
        			return nil
        		end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = tabContent
        		lblConfig.Y = currentY
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		currentY = currentY + 25
        		updateTabCanvasSize()

        		return labelAPI
        	end

        	-- Add Separator Component
        	function tabAPI:AddSeparator(separatorConfig)
        		if not Separator then
        			return nil
        		end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = tabContent
        		separatorConfig.Y = currentY

        		local separatorAPI = Separator:Create(separatorConfig)
        		currentY = currentY + 15
        		updateTabCanvasSize()

        		return separatorAPI
        	end

        	-- Add Accordion Component (USING MODULAR ACCORDION)
        	function tabAPI:AddAccordion(accordionConfig)
        		if not Accordion then
        			return nil
        		end

        		accordionConfig = accordionConfig or {}

        		-- Set parent and position
        		accordionConfig.Parent = tabContent
        		accordionConfig.Y = currentY

        		-- Pass through EzUI config
        		accordionConfig.EzUI = config.EzUI
        		accordionConfig.SaveConfiguration = config.SaveConfiguration
        		accordionConfig.RegisterComponent = config.RegisterComponent
        		accordionConfig.Settings= config.Settings
        		accordionConfig.ScreenGui = config.ScreenGui

        		-- Pass callback for height changes
        		accordionConfig.OnHeightChanged = function()
        			-- Recalculate tab height
        			local maxY = 10

        			for _, child in pairs(tabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childBottom = child.Position.Y.Offset + child.AbsoluteSize.Y
        					maxY = math.max(maxY, childBottom)
        				end
        			end

        			-- Update currentY (reduced spacing)
        			currentY = maxY + 5

        			-- Use our unified canvas update function
        			updateTabCanvasSize()
        		end

        		-- Create accordion using module
        		local accordionAPI = Accordion:Create(accordionConfig)

        		-- Update currentY for next component based on actual container size (reduced spacing)
        		task.wait() -- Ensure size is rendered
        		local actualHeight = accordionAPI.Container.AbsoluteSize.Y
        		currentY = currentY + actualHeight + 5
        		updateTabCanvasSize()

        		return accordionAPI
        	end

        	return tabAPI
        end

        return Tab

    end

    -- Module: components/numberbox
    EmbeddedModules["components/numberbox"] = function()
        --[[
        	NumberBox Component
        	EzUI Library - Modular Component

        	Creates a numeric input field with increment/decrement buttons
        ]]
        local NumberBox = {}

        local Colors

        function NumberBox:Init(_colors)
        	Colors = _colors
        end

        function NumberBox:Create(config)
        	local placeholder = config.Placeholder or "Enter number..."
        	local defaultValue = config.Default or 0
        	local callback = config.Callback or function() end
        	local minValue = config.Min or -math.huge
        	local maxValue = config.Max or math.huge
        	local increment = config.Increment or 1
        	local decimals = config.Decimals or 0
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- NumberBox state
        	local currentValue = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			currentValue = flagValue
        			defaultValue = currentValue
        		end
        	end

        	-- Main numberbox container
        	local numberBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		numberBoxContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion numberboxes - let UIListLayout handle it
        		numberBoxContainer.ZIndex = 6
        	else
        		numberBoxContainer.Size = UDim2.new(1, -20, 0, 30)
        		numberBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		numberBoxContainer.ZIndex = 3
        		numberBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	numberBoxContainer.BackgroundTransparency = 1
        	numberBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	numberBoxContainer.Parent = parentContainer

        	-- Number input box
        	local numberBox = Instance.new("TextBox")
        	if isForAccordion then
        		numberBox.Size = UDim2.new(1, -45, 1, 0)
        		numberBox.TextSize = 12
        		numberBox.ZIndex = 7
        	else
        		numberBox.Size = UDim2.new(1, -60, 1, 0)
        		numberBox.TextSize = 14
        		numberBox.ZIndex = 4
        	end
        	numberBox.Position = UDim2.new(0, 0, 0, 0)
        	numberBox.BackgroundColor3 = Colors.Input.Background
        	numberBox.BorderColor3 = Colors.Input.Border
        	numberBox.BorderSizePixel = 1
        	numberBox.Text = decimals > 0 and string.format("%." .. decimals .. "f", defaultValue) or tostring(defaultValue)
        	numberBox.PlaceholderText = placeholder
        	numberBox.TextColor3 = Colors.Input.Text
        	numberBox.PlaceholderColor3 = Colors.Input.Placeholder
        	numberBox.Font = Enum.Font.SourceSans
        	numberBox.TextXAlignment = Enum.TextXAlignment.Center
        	numberBox.TextYAlignment = Enum.TextYAlignment.Center
        	numberBox.TextScaled = false -- Prevent text from scaling down automatically
        	numberBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	numberBox.ClearTextOnFocus = false
        	numberBox.Parent = numberBoxContainer

        	-- Add padding to NumberBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.Parent = numberBox

        	-- Round corners for number box
        	local numberCorner = Instance.new("UICorner")
        	numberCorner.CornerRadius = UDim.new(0, 4)
        	numberCorner.Parent = numberBox

        	-- Increment button (up arrow)
        	local incrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		incrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		incrementBtn.Position = UDim2.new(1, -22, 0, 1)
        		incrementBtn.TextSize = 8
        		incrementBtn.ZIndex = 7
        	else
        		incrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		incrementBtn.Position = UDim2.new(1, -30, 0, 1)
        		incrementBtn.TextSize = 10
        		incrementBtn.ZIndex = 4
        	end
        	incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	incrementBtn.BorderColor3 = Colors.Border.Default
        	incrementBtn.BorderSizePixel = 1
        	incrementBtn.Text = "▲"
        	incrementBtn.TextColor3 = Colors.Text.Secondary
        	incrementBtn.Font = Enum.Font.SourceSans
        	incrementBtn.Parent = numberBoxContainer

        	-- Decrement button (down arrow)
        	local decrementBtn = Instance.new("TextButton")
        	if isForAccordion then
        		decrementBtn.Size = UDim2.new(0, 20, 0, 12)
        		decrementBtn.Position = UDim2.new(1, -22, 0, 13)
        		decrementBtn.TextSize = 8
        		decrementBtn.ZIndex = 7
        	else
        		decrementBtn.Size = UDim2.new(0, 25, 0, 14)
        		decrementBtn.Position = UDim2.new(1, -30, 0, 15)
        		decrementBtn.TextSize = 10
        		decrementBtn.ZIndex = 4
        	end
        	decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	decrementBtn.BorderColor3 = Colors.Border.Default
        	decrementBtn.BorderSizePixel = 1
        	decrementBtn.Text = "▼"
        	decrementBtn.TextColor3 = Colors.Text.Secondary
        	decrementBtn.Font = Enum.Font.SourceSans
        	decrementBtn.Parent = numberBoxContainer

        	-- Function to validate and update value
        	local function updateValue(newValue)
        		-- Clamp to min/max
        		newValue = math.max(minValue, math.min(maxValue, newValue))

        		-- Round to decimal places
        		if decimals > 0 then
        			local multiplier = 10 ^ decimals
        			newValue = math.floor(newValue * multiplier + 0.5) / multiplier
        		else
        			newValue = math.floor(newValue + 0.5)
        		end

        		currentValue = newValue

        		-- Update text box display
        		if decimals > 0 then
        			numberBox.Text = string.format("%." .. decimals .. "f", newValue)
        		else
        			numberBox.Text = tostring(newValue)
        		end

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentValue)
        		end
        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(currentValue)
        		end)

        		if not success then
        		end

        		return newValue
        	end 

        	-- Text change handler with validation
        	numberBox.FocusLost:Connect(function()
        		local inputText = numberBox.Text
        		local numValue = tonumber(inputText)

        		if numValue then
        			updateValue(numValue)
        		else
        			-- Invalid input, revert to current value
        			if decimals > 0 then
        				numberBox.Text = string.format("%." .. decimals .. "f", currentValue)
        			else
        				numberBox.Text = tostring(currentValue)
        			end
        		end
        	end)

        	-- Increment button handler
        	incrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue + increment)
        	end)

        	-- Decrement button handler
        	decrementBtn.MouseButton1Click:Connect(function()
        		updateValue(currentValue - increment)
        	end)

        	-- Button hover effects
        	incrementBtn.MouseEnter:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	incrementBtn.MouseLeave:Connect(function()
        		incrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	decrementBtn.MouseEnter:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	decrementBtn.MouseLeave:Connect(function()
        		decrementBtn.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Focus effects
        	numberBox.Focused:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	numberBox.FocusLost:Connect(function()
        		numberBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return NumberBox API
        	local numberBoxAPI = {
        		NumberBox = numberBoxContainer
        	}

        	function numberBoxAPI:GetValue()
        		return currentValue
        	end

        	function numberBoxAPI:SetValue(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		else
        		end
        	end

        	function numberBoxAPI:SetMin(newMin)
        		minValue = tonumber(newMin) or -math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetMax(newMax)
        		maxValue = tonumber(newMax) or math.huge
        		updateValue(currentValue)
        	end

        	function numberBoxAPI:SetIncrement(newIncrement)
        		increment = tonumber(newIncrement) or 1
        	end

        	function numberBoxAPI:Clear()
        		updateValue(0)
        	end

        	function numberBoxAPI:Focus()
        		numberBox:CaptureFocus()
        	end

        	function numberBoxAPI:Blur()
        		numberBox:ReleaseFocus()
        	end

        	function numberBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function numberBoxAPI:Set(newValue)
        		local numValue = tonumber(newValue)
        		if numValue then
        			updateValue(numValue)
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, numberBoxAPI)
        	end

        	return numberBoxAPI
        end

        return NumberBox

    end

    -- Module: components/notification
    EmbeddedModules["components/notification"] = function()
        --[[
        	Notification Component (Sonner-style)
        	EzUI Library - Modular Component

        	Creates toast notifications with stacking, animations, and different types
        	Similar to Sonner from shadcn/ui
        ]]

        local Notification = {}

        local Colors
        local TweenService = game:GetService("TweenService")

        -- Global notification container and state
        local NotificationContainer = nil
        local ActiveNotifications = {}
        local NotificationId = 0
        local MaxNotifications = 5
        local NotificationWidth = 300  -- Reduced from 350
        local NotificationHeight = 55  -- Reduced from 70
        local StackOffset = 6          -- Reduced from 8
        local AnimationDuration = 0.3

        function Notification:Init(_colors)
        	Colors = _colors
        end

        -- Initialize the global notification container
        local function initializeContainer(screenGui)
        	if NotificationContainer then return end

        	NotificationContainer = Instance.new("Frame")
        	NotificationContainer.Name = "NotificationContainer"
        	NotificationContainer.Size = UDim2.new(0, NotificationWidth + 20, 1, 0)
        	NotificationContainer.Position = UDim2.new(1, -NotificationWidth - 30, 0, 0) -- Top right
        	NotificationContainer.BackgroundTransparency = 1
        	NotificationContainer.ZIndex = 1000
        	NotificationContainer.Parent = screenGui
        end

        -- Create individual notification
        local function createNotification(config)
        	local notificationType = config.Type or "info" -- info, success, warning, error
        	local title = config.Title or ""
        	local message = config.Message or config.Description or ""
        	local duration = config.Duration or 4000 -- milliseconds
        	local action = config.Action -- {label, callback}
        	local onDismiss = config.OnDismiss

        	-- Generate unique ID
        	NotificationId = NotificationId + 1
        	local id = NotificationId

        	-- Create notification frame
        	local notification = Instance.new("Frame")
        	notification.Name = "Notification_" .. id
        	notification.Size = UDim2.new(0, NotificationWidth, 0, NotificationHeight)
        	notification.Position = UDim2.new(0, 10, 0, 20) -- Start position
        	notification.BackgroundColor3 = Colors.Surface.Elevated
        	notification.BorderSizePixel = 0
        	notification.ZIndex = 1001
        	notification.ClipsDescendants = false
        	notification.Parent = NotificationContainer

        	-- Notification corner radius
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 8)
        	corner.Parent = notification

        	-- Notification border/stroke
        	local stroke = Instance.new("UIStroke")
        	stroke.Thickness = 1
        	stroke.Transparency = 0.8

        	-- Type-specific colors
        	if notificationType == "success" then
        		stroke.Color = Colors.Status.Success
        	elseif notificationType == "warning" then
        		stroke.Color = Colors.Status.Warning
        	elseif notificationType == "error" then
        		stroke.Color = Colors.Status.Error
        	else -- info
        		stroke.Color = Colors.Border.Default
        	end
        	stroke.Parent = notification

        	-- Subtle shadow effect
        	local shadow = Instance.new("Frame")
        	shadow.Size = UDim2.new(1, 4, 1, 4)
        	shadow.Position = UDim2.new(0, -2, 0, 2)
        	shadow.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	shadow.BackgroundTransparency = 0.9
        	shadow.ZIndex = notification.ZIndex - 1
        	shadow.Parent = notification

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 10)
        	shadowCorner.Parent = shadow

        	-- Status indicator (colored bar)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 4, 1, -12)
        	indicator.Position = UDim2.new(0, 6, 0, 6)
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = notification.ZIndex + 1
        	indicator.Parent = notification

        	if notificationType == "success" then
        		indicator.BackgroundColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		indicator.BackgroundColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		indicator.BackgroundColor3 = Colors.Status.Error
        	else -- info
        		indicator.BackgroundColor3 = Colors.Accent.Primary
        	end

        	local indicatorCorner = Instance.new("UICorner")
        	indicatorCorner.CornerRadius = UDim.new(0, 2)
        	indicatorCorner.Parent = indicator

        	-- Icon (emoji-based for simplicity, more compact)
        	local icon = Instance.new("TextLabel")
        	icon.Size = UDim2.new(0, 16, 0, 16)  -- Reduced from 20x20
        	icon.Position = UDim2.new(0, 16, 0, 8)  -- Closer to edges
        	icon.BackgroundTransparency = 1
        	icon.Font = Enum.Font.GothamBold  -- Use bold for better icon visibility
        	icon.TextSize = 14  -- Reduced from 16
        	icon.TextColor3 = Colors.Text.Primary
        	icon.TextXAlignment = Enum.TextXAlignment.Center
        	icon.TextYAlignment = Enum.TextYAlignment.Center
        	icon.ZIndex = notification.ZIndex + 1
        	icon.Parent = notification

        	if notificationType == "success" then
        		icon.Text = "✓"
        		icon.TextColor3 = Colors.Status.Success
        	elseif notificationType == "warning" then
        		icon.Text = "⚠"
        		icon.TextColor3 = Colors.Status.Warning
        	elseif notificationType == "error" then
        		icon.Text = "!"  -- Changed to exclamation mark for better visibility
        		icon.TextColor3 = Colors.Status.Error
        		icon.TextSize = 16  -- Slightly larger for error icon
        	else -- info
        		icon.Text = "i"  -- Changed to simple 'i' for info
        		icon.TextColor3 = Colors.Accent.Primary
        	end

        	-- Content container (more compact)
        	local contentContainer = Instance.new("Frame")
        	contentContainer.Size = UDim2.new(1, action and -80 or -50, 1, -8)  -- Reduced margins
        	contentContainer.Position = UDim2.new(0, 40, 0, 4)  -- Closer positioning
        	contentContainer.BackgroundTransparency = 1
        	contentContainer.ZIndex = notification.ZIndex + 1
        	contentContainer.Parent = notification

        	-- Title (more compact)
        	local hasTitle = title and title ~= ""
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, 16)  -- Reduced from 18
        		titleLabel.Position = UDim2.new(0, 0, 0, 1)  -- Reduced from 2
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = title
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.TextYAlignment = Enum.TextYAlignment.Top
        		titleLabel.Font = Enum.Font.GothamBold
        		titleLabel.TextSize = 13  -- Reduced from 14
        		titleLabel.TextTruncate = Enum.TextTruncate.AtEnd
        		titleLabel.ZIndex = contentContainer.ZIndex + 1
        		titleLabel.Parent = contentContainer
        	end

        	-- Message (more compact)
        	if message and message ~= "" then
        		local messageLabel = Instance.new("TextLabel")
        		messageLabel.Size = UDim2.new(1, 0, hasTitle and 0, 14 or 1, 0)  -- Reduced from 16
        		messageLabel.Position = UDim2.new(0, 0, hasTitle and 0, 17 or 0, 0)  -- Reduced from 20
        		messageLabel.BackgroundTransparency = 1
        		messageLabel.Text = message
        		messageLabel.TextColor3 = Colors.Text.Secondary
        		messageLabel.TextXAlignment = Enum.TextXAlignment.Left
        		messageLabel.TextYAlignment = hasTitle and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        		messageLabel.Font = Enum.Font.Gotham
        		messageLabel.TextSize = 11  -- Reduced from 12
        		messageLabel.TextWrapped = true
        		messageLabel.ZIndex = contentContainer.ZIndex + 1
        		messageLabel.Parent = contentContainer
        	end

        	-- Action button (more compact)
        	if action then
        		local actionButton = Instance.new("TextButton")
        		actionButton.Size = UDim2.new(0, 50, 0, 20)  -- Reduced from 60x24
        		actionButton.Position = UDim2.new(1, -55, 0.5, -10)  -- Adjusted position
        		actionButton.BackgroundColor3 = Colors.Button.Primary
        		actionButton.BorderSizePixel = 0
        		actionButton.Text = action.label or "Action"
        		actionButton.TextColor3 = Color3.fromRGB(255, 255, 255)
        		actionButton.Font = Enum.Font.Gotham
        		actionButton.TextSize = 10  -- Reduced from 11
        		actionButton.ZIndex = notification.ZIndex + 2
        		actionButton.Parent = notification

        		local actionCorner = Instance.new("UICorner")
        		actionCorner.CornerRadius = UDim.new(0, 4)
        		actionCorner.Parent = actionButton

        		-- Action button hover
        		actionButton.MouseEnter:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.PrimaryHover
        			})
        			tween:Play()
        		end)

        		actionButton.MouseLeave:Connect(function()
        			local tween = TweenService:Create(actionButton, TweenInfo.new(0.2), {
        				BackgroundColor3 = Colors.Button.Primary
        			})
        			tween:Play()
        		end)

        		actionButton.MouseButton1Click:Connect(function()
        			if action.callback then
        				action.callback()
        			end
        			Notification:Dismiss(id)
        		end)
        	end

        	-- Close button (moved to top-right corner)
        	local closeButton = Instance.new("TextButton")
        	closeButton.Size = UDim2.new(0, 20, 0, 20)
        	closeButton.Position = UDim2.new(1, -24, 0, 0)  -- Moved even closer to top edge
        	closeButton.BackgroundTransparency = 1
        	closeButton.Text = "×"
        	closeButton.TextColor3 = Colors.Text.Secondary
        	closeButton.TextSize = 16
        	closeButton.Font = Enum.Font.GothamBold
        	closeButton.ZIndex = notification.ZIndex + 2
        	closeButton.Parent = notification

        	-- Close button hover
        	closeButton.MouseEnter:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Primary
        		closeButton.BackgroundTransparency = 0.9
        		closeButton.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	closeButton.MouseLeave:Connect(function()
        		closeButton.TextColor3 = Colors.Text.Secondary
        		closeButton.BackgroundTransparency = 1
        	end)

        	closeButton.MouseButton1Click:Connect(function()
        		Notification:Dismiss(id)
        	end)

        	-- Progress bar (for duration, more compact)
        	local progressBar = Instance.new("Frame")
        	progressBar.Size = UDim2.new(1, -8, 0, 2)  -- Slightly wider (reduced margin from 12 to 8)
        	progressBar.Position = UDim2.new(0, 4, 1, -6)  -- Adjusted position (closer to bottom edge)
        	progressBar.BackgroundColor3 = indicator.BackgroundColor3
        	progressBar.BackgroundTransparency = 0.7
        	progressBar.BorderSizePixel = 0
        	progressBar.ZIndex = notification.ZIndex + 1
        	progressBar.Parent = notification

        	local progressCorner = Instance.new("UICorner")
        	progressCorner.CornerRadius = UDim.new(0, 1)
        	progressCorner.Parent = progressBar

        	-- Store notification data
        	local notificationData = {
        		id = id,
        		frame = notification,
        		duration = duration,
        		onDismiss = onDismiss,
        		startTime = tick() * 1000,
        		progressBar = progressBar
        	}

        	table.insert(ActiveNotifications, notificationData)

        	-- Calculate proper position for this notification
        	local notificationIndex = #ActiveNotifications
        	local yOffset = 20 + ((notificationIndex - 1) * (NotificationHeight + StackOffset))

        	-- Animate in from off-screen to proper stacked position
        	notification.Position = UDim2.new(1, 0, 0, yOffset) -- Start off-screen at correct Y
        	local slideIn = TweenService:Create(notification, 
        		TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        		{Position = UDim2.new(0, 10, 0, yOffset)}
        	)
        	slideIn:Play()

        	-- Update positions for all other notifications (to apply stacking effects)
        	updateNotificationPositions()

        	-- Auto dismiss after duration
        	if duration > 0 then
        		task.spawn(function()
        			local startTime = tick() * 1000
        			while true do
        				task.wait(0.1)
        				local elapsed = (tick() * 1000) - startTime
        				local progress = elapsed / duration

        				if progress >= 1 then
        					Notification:Dismiss(id)
        					break
        				end

        				-- Update progress bar
        				progressBar.Size = UDim2.new(1 - progress, -12, 0, 2)
        			end
        		end)
        	end

        	-- Remove old notifications if exceeding max
        	if #ActiveNotifications > MaxNotifications then
        		Notification:Dismiss(ActiveNotifications[1].id)
        	end

        	return id
        end

        -- Update notification positions with stacking effect
        function updateNotificationPositions()
        	for i, notificationData in ipairs(ActiveNotifications) do
        		local yOffset = 20 + ((i - 1) * (NotificationHeight + StackOffset))
        		local scale = math.max(0.95, 1 - ((i - 1) * 0.02)) -- Slight scale reduction for stacked items
        		local transparency = math.min(0.3, (i - 1) * 0.1) -- Slight transparency for stacked items

        		local tween = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{
        				Position = UDim2.new(0, 10, 0, yOffset),
        				Size = UDim2.new(0, NotificationWidth * scale, 0, NotificationHeight * scale)
        			}
        		)
        		tween:Play()

        		-- Apply transparency to stacked notifications
        		if i > 1 then
        			notificationData.frame.BackgroundTransparency = transparency
        		else
        			notificationData.frame.BackgroundTransparency = 0
        		end
        	end
        end

        -- Public API
        function Notification:Create(config)
        	if not config then
        		return nil
        	end

        	-- Initialize container if needed
        	local screenGui = config.ScreenGui or game.Players.LocalPlayer:WaitForChild("PlayerGui"):FindFirstChildOfClass("ScreenGui")
        	initializeContainer(screenGui)

        	return createNotification(config)
        end

        -- Dismiss notification by ID
        function Notification:Dismiss(id)
        	for i, notificationData in ipairs(ActiveNotifications) do
        		if notificationData.id == id then
        			-- Animate out
        			local slideOut = TweenService:Create(notificationData.frame,
        				TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        			)

        			slideOut:Play()
        			slideOut.Completed:Connect(function()
        				notificationData.frame:Destroy()
        			end)

        			-- Call dismiss callback
        			if notificationData.onDismiss then
        				notificationData.onDismiss()
        			end

        			-- Remove from active notifications
        			table.remove(ActiveNotifications, i)

        			-- Update positions
        			updateNotificationPositions()
        			break
        		end
        	end
        end

        -- Clear all notifications
        function Notification:Clear()
        	for _, notificationData in ipairs(ActiveNotifications) do
        		local slideOut = TweenService:Create(notificationData.frame,
        			TweenInfo.new(AnimationDuration, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = UDim2.new(1, 0, notificationData.frame.Position.Y.Scale, notificationData.frame.Position.Y.Offset)}
        		)
        		slideOut:Play()
        		slideOut.Completed:Connect(function()
        			notificationData.frame:Destroy()
        		end)
        	end
        	ActiveNotifications = {}
        end

        -- Convenience methods for different types
        function Notification:Success(config)
        	config = config or {}
        	config.Type = "success"
        	return self:Create(config)
        end

        function Notification:Warning(config)
        	config = config or {}
        	config.Type = "warning"
        	return self:Create(config)
        end

        function Notification:Error(config)
        	config = config or {}
        	config.Type = "error"
        	return self:Create(config)
        end

        function Notification:Info(config)
        	config = config or {}
        	config.Type = "info"
        	return self:Create(config)
        end

        return Notification
    end

    -- Module: components/selectbox
    EmbeddedModules["components/selectbox"] = function()
        --[[
        local Colors = require(game.ReplicatedStorage.utils.colors)
        	SelectBox Component
        	EzUI Library - Modular Component

        	Creates a dropdown select box with search and multi-select support
        	Note: This is a simplified modular version. For full features, use the main UI library.
        ]]
        local SelectBox = {}

        local Colors

        function SelectBox:Init(_colors)
        	Colors = _colors
        end

        function SelectBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local rawOptions = config.Options or {"Option 1", "Option 2", "Option 3"}
        	local placeholder = config.Placeholder or "Select option..."
        	local multiSelect = config.MultiSelect or false
        	local callback = config.Callback or function() end
        	local onDropdownOpen = config.OnDropdownOpen or function() end
        	local onInit = config.OnInit or function() end
        	local bottomSheetMaxHeight = config.BottomSheetHeight or config.MaxHeight or 320
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local screenGui = config.ScreenGui
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Normalize options to {text, value} format
        	local options = {}
        	for i, option in ipairs(rawOptions) do
        		if type(option) == "string" then
        			table.insert(options, {text = option, value = option})
        		elseif type(option) == "table" and option.text and option.value then
        			table.insert(options, option)
        		end
        	end

        	local selectedValues = {}
        	local isOpen = false

        	-- Title configuration
        	local hasTitle = name and name ~= ""
        	local labelHeight = isForAccordion and 16 or 18
        	local selectHeight = isForAccordion and 25 or 30
        	local totalHeight = hasTitle and (labelHeight + selectHeight + 2) or selectHeight

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			if type(flagValue) == "table" then
        				selectedValues = flagValue
        			elseif flagValue ~= "" then
        				selectedValues = {flagValue}
        			end
        		end
        	end

        	-- Main container
        	local selectContainer = Instance.new("Frame")
        	if isForAccordion then
        		selectContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		-- Don't set Position for accordion selectboxes - let UIListLayout handle it
        		selectContainer.ZIndex = 6
        	else
        		selectContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		selectContainer.Position = UDim2.new(0, 10, 0, currentY)
        		selectContainer.ZIndex = 3
        		selectContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	selectContainer.BackgroundTransparency = 1
        	selectContainer.ClipsDescendants = false
        	selectContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = selectContainer
        	end

        	-- Select button (modern design)
        	local selectButton = Instance.new("TextButton")
        	if hasTitle then
        		selectButton.Size = UDim2.new(1, 0, 0, selectHeight)
        		selectButton.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		selectButton.Size = UDim2.new(1, 0, 1, 0)
        		selectButton.Position = UDim2.new(0, 0, 0, 0)
        	end
        	selectButton.BackgroundColor3 = Colors.Input.Background
        	selectButton.BorderSizePixel = 0
        	selectButton.Text = "  " .. placeholder
        	selectButton.TextColor3 = Colors.Text.Secondary
        	selectButton.TextXAlignment = Enum.TextXAlignment.Left
        	selectButton.Font = Enum.Font.Gotham
        	selectButton.TextSize = isForAccordion and 12 or 14
        	selectButton.TextScaled = false
        	selectButton.ClipsDescendants = true
        	selectButton.ZIndex = isForAccordion and 7 or 4
        	selectButton.Parent = selectContainer

        	-- Chips container for multi-select (scrollable, tighter spacing)
        	local chipsContainer = Instance.new("ScrollingFrame")
        	chipsContainer.Size = UDim2.new(1, -24, 1, -2) -- Reduced gap to arrow
        	chipsContainer.Position = UDim2.new(0, 8, 0, 1)
        	chipsContainer.BackgroundTransparency = 1
        	chipsContainer.BorderSizePixel = 0
        	chipsContainer.ClipsDescendants = true
        	chipsContainer.ScrollBarThickness = 0 -- Hide scrollbar for cleaner look
        	chipsContainer.ScrollingDirection = Enum.ScrollingDirection.X -- Horizontal scroll
        	chipsContainer.CanvasSize = UDim2.new(0, 0, 0, 0) -- Will be auto-calculated
        	chipsContainer.ZIndex = selectButton.ZIndex + 1
        	chipsContainer.Parent = selectButton
        	chipsContainer.Visible = false -- Initially hidden

        	-- Chips layout
        	local chipsLayout = Instance.new("UIListLayout")
        	chipsLayout.FillDirection = Enum.FillDirection.Horizontal
        	chipsLayout.HorizontalAlignment = Enum.HorizontalAlignment.Left
        	chipsLayout.VerticalAlignment = Enum.VerticalAlignment.Center
        	chipsLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	chipsLayout.Padding = UDim.new(0, 4)
        	chipsLayout.Wraps = false -- No wrapping since we're scrolling horizontally
        	chipsLayout.Parent = chipsContainer

        	-- Modern rounded corners
        	local selectCorner = Instance.new("UICorner")
        	selectCorner.CornerRadius = UDim.new(0, 8)
        	selectCorner.Parent = selectButton

        	-- Subtle border effect
        	local selectStroke = Instance.new("UIStroke")
        	selectStroke.Color = Colors.Input.Border
        	selectStroke.Thickness = 1
        	selectStroke.Parent = selectButton

        	-- Padding for better text spacing (further reduced right padding)
        	local selectPadding = Instance.new("UIPadding")
        	selectPadding.PaddingLeft = UDim.new(0, 8)
        	selectPadding.PaddingRight = UDim.new(0, 24)
        	selectPadding.PaddingTop = UDim.new(0, 1)
        	selectPadding.PaddingBottom = UDim.new(0, 1)
        	selectPadding.Parent = selectButton

        	-- Modern arrow icon (embedded in select button, tighter positioning)
        	local arrow = Instance.new("TextLabel")
        	if hasTitle then
        		arrow.Size = UDim2.new(0, 20, 0, selectHeight)
        		arrow.Position = UDim2.new(1, -20, 0, labelHeight + 2)
        	else
        		arrow.Size = UDim2.new(0, 20, 1, 0)
        		arrow.Position = UDim2.new(1, -20, 0, 0)
        	end
        	arrow.BackgroundTransparency = 1
        	arrow.Text = "▼"
        	arrow.TextColor3 = Colors.Text.Secondary
        	arrow.TextXAlignment = Enum.TextXAlignment.Center
        	arrow.TextYAlignment = Enum.TextYAlignment.Center
        	arrow.Font = Enum.Font.GothamBold
        	arrow.TextSize = isForAccordion and 14 or 16
        	arrow.ZIndex = isForAccordion and 8 or 5
        	arrow.Parent = selectContainer

        	-- Find the window frame container
        	local windowFrame = screenGui and screenGui:FindFirstChild("Frame") or selectContainer.Parent
        	while windowFrame and not (windowFrame.Name:find("Frame") and windowFrame.Parent == screenGui) do
        		windowFrame = windowFrame.Parent
        		if windowFrame == screenGui or not windowFrame then
        			windowFrame = screenGui:FindFirstChildOfClass("Frame")
        			break
        		end
        	end

        	-- Bottom sheet overlay (TextButton for click detection)
        	local bottomSheetOverlay = Instance.new("TextButton")
        	bottomSheetOverlay.Size = UDim2.new(1, 0, 1, 0)
        	bottomSheetOverlay.Position = UDim2.new(0, 0, 0, 0)
        	bottomSheetOverlay.BackgroundColor3 = Color3.fromRGB(0, 0, 0)
        	bottomSheetOverlay.BackgroundTransparency = 0.5
        	bottomSheetOverlay.BorderSizePixel = 0
        	bottomSheetOverlay.Text = ""
        	bottomSheetOverlay.Visible = false
        	bottomSheetOverlay.ZIndex = 100
        	bottomSheetOverlay.Parent = windowFrame or screenGui or selectContainer.Parent

        	-- Bottom sheet container (customizable height)
        	local bottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        	local bottomSheet = Instance.new("Frame")
        	bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        	bottomSheet.Position = UDim2.new(0, 20, 1, 0) -- Start below window
        	bottomSheet.BackgroundColor3 = Colors.Surface.Default
        	bottomSheet.BorderSizePixel = 0
        	bottomSheet.ZIndex = 101
        	bottomSheet.Parent = bottomSheetOverlay

        	-- Modern rounded corners for bottom sheet
        	local bottomSheetCorner = Instance.new("UICorner")
        	bottomSheetCorner.CornerRadius = UDim.new(0, 12)
        	bottomSheetCorner.Parent = bottomSheet

        	-- Handle bar at top of bottom sheet (smaller)
        	local handleBar = Instance.new("Frame")
        	handleBar.Size = UDim2.new(0, 32, 0, 3)
        	handleBar.Position = UDim2.new(0.5, -16, 0, 6)
        	handleBar.BackgroundColor3 = Colors.Text.Secondary
        	handleBar.BorderSizePixel = 0
        	handleBar.ZIndex = 102
        	handleBar.Parent = bottomSheet

        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 1.5)
        	handleCorner.Parent = handleBar

        	-- Title for bottom sheet (smaller)
        	local sheetTitle = Instance.new("TextLabel")
        	sheetTitle.Size = UDim2.new(1, -32, 0, 24)
        	sheetTitle.Position = UDim2.new(0, 16, 0, 16)
        	sheetTitle.BackgroundTransparency = 1
        	sheetTitle.Text = name ~= "" and name or "Select Option"
        	sheetTitle.TextColor3 = Colors.Text.Primary
        	sheetTitle.TextXAlignment = Enum.TextXAlignment.Left
        	sheetTitle.TextYAlignment = Enum.TextYAlignment.Center
        	sheetTitle.Font = Enum.Font.GothamBold
        	sheetTitle.TextSize = 16
        	sheetTitle.ZIndex = 102
        	sheetTitle.Parent = bottomSheet

        	-- Modern search box (smaller)
        	local searchBox = Instance.new("TextBox")
        	searchBox.Size = UDim2.new(1, -32, 0, 32)
        	searchBox.Position = UDim2.new(0, 16, 0, 48)
        	searchBox.BackgroundColor3 = Colors.Input.Background
        	searchBox.BorderSizePixel = 0
        	searchBox.PlaceholderText = "🔍 Search options..."
        	searchBox.Text = ""
        	searchBox.TextColor3 = Colors.Text.Primary
        	searchBox.Font = Enum.Font.Gotham
        	searchBox.TextSize = 13
        	searchBox.TextXAlignment = Enum.TextXAlignment.Left
        	searchBox.ZIndex = 102
        	searchBox.Parent = bottomSheet

        	-- Search box styling
        	local searchCorner = Instance.new("UICorner")
        	searchCorner.CornerRadius = UDim.new(0, 6)
        	searchCorner.Parent = searchBox

        	local searchPadding = Instance.new("UIPadding")
        	searchPadding.PaddingLeft = UDim.new(0, 12)
        	searchPadding.PaddingRight = UDim.new(0, 12)
        	searchPadding.Parent = searchBox

        	-- Options container (scrollable, smaller)
        	local optionsScrollFrame = Instance.new("ScrollingFrame")
        	optionsScrollFrame.Size = UDim2.new(1, -32, 1, -96)
        	optionsScrollFrame.Position = UDim2.new(0, 16, 0, 88)
        	optionsScrollFrame.BackgroundTransparency = 1
        	optionsScrollFrame.BorderSizePixel = 0
        	optionsScrollFrame.ScrollBarThickness = 4
        	optionsScrollFrame.ScrollBarImageColor3 = Colors.Accent.Primary
        	optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	optionsScrollFrame.ZIndex = 102
        	optionsScrollFrame.Parent = bottomSheet

        	local optionsContainer = Instance.new("Frame")
        	optionsContainer.Size = UDim2.new(1, 0, 0, 0) -- Auto-size based on content
        	optionsContainer.Position = UDim2.new(0, 0, 0, 0)
        	optionsContainer.BackgroundTransparency = 1
        	optionsContainer.ZIndex = 103
        	optionsContainer.Parent = optionsScrollFrame

        	-- List layout
        	local listLayout = Instance.new("UIListLayout")
        	listLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	listLayout.Parent = optionsContainer

        	-- Forward declarations
        	local updateDisplayText, refreshOptions, removeSelectedValue

        	-- Update display text and chips
        	function updateDisplayText()
        		-- Clear existing chips
        		for _, child in pairs(chipsContainer:GetChildren()) do
        			if child:IsA("Frame") then
        				child:Destroy()
        			end
        		end

        		if #selectedValues == 0 then
        			-- Show placeholder text
        			selectButton.Text = "  " .. placeholder
        			selectButton.TextColor3 = Colors.Text.Secondary
        			chipsContainer.Visible = false
        		elseif multiSelect and #selectedValues > 0 then
        			-- Hide button text and show chips
        			selectButton.Text = ""
        			chipsContainer.Visible = true

        			local totalWidth = 0

        			-- Create chips for all selected items
        			for i, value in ipairs(selectedValues) do
        				local displayText = value
        				for _, option in ipairs(options) do
        					if option.value == value then
        						displayText = option.text
        						break
        					end
        				end

        				-- Create chip container
        				local chip = Instance.new("Frame")
        				chip.Size = UDim2.new(0, 0, 0, selectHeight - 8) -- Auto-width, fit height
        				chip.BackgroundColor3 = Colors.Accent.Primary
        				chip.BorderSizePixel = 0
        				chip.ZIndex = chipsContainer.ZIndex + 1
        				chip.LayoutOrder = i
        				chip.Parent = chipsContainer

        				-- Chip corner radius
        				local chipCorner = Instance.new("UICorner")
        				chipCorner.CornerRadius = UDim.new(0, (selectHeight - 8) / 2) -- Pill shape
        				chipCorner.Parent = chip

        				-- Chip text
        				local chipText = Instance.new("TextLabel")
        				chipText.Size = UDim2.new(1, -20, 1, 0) -- Leave space for X button
        				chipText.Position = UDim2.new(0, 8, 0, 0)
        				chipText.BackgroundTransparency = 1
        				chipText.Text = displayText
        				chipText.TextColor3 = Color3.fromRGB(255, 255, 255)
        				chipText.TextXAlignment = Enum.TextXAlignment.Left
        				chipText.TextYAlignment = Enum.TextYAlignment.Center
        				chipText.Font = Enum.Font.Gotham
        				chipText.TextSize = isForAccordion and 10 or 12
        				chipText.TextScaled = false
        				chipText.ZIndex = chip.ZIndex + 1
        				chipText.Parent = chip

        				-- X button for removing chip
        				local removeButton = Instance.new("TextButton")
        				removeButton.Size = UDim2.new(0, 16, 0, 16)
        				removeButton.Position = UDim2.new(1, -18, 0.5, -8)
        				removeButton.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
        				removeButton.BackgroundTransparency = 0.2
        				removeButton.BorderSizePixel = 0
        				removeButton.Text = "×"
        				removeButton.TextColor3 = Colors.Accent.Primary
        				removeButton.TextSize = 12
        				removeButton.Font = Enum.Font.GothamBold
        				removeButton.ZIndex = chip.ZIndex + 2
        				removeButton.Parent = chip

        				-- X button corner radius
        				local removeCorner = Instance.new("UICorner")
        				removeCorner.CornerRadius = UDim.new(0, 8)
        				removeCorner.Parent = removeButton

        				-- X button hover effect
        				removeButton.MouseEnter:Connect(function()
        					removeButton.BackgroundTransparency = 0
        				end)

        				removeButton.MouseLeave:Connect(function()
        					removeButton.BackgroundTransparency = 0.2
        				end)

        				-- Remove chip on click
        				removeButton.MouseButton1Click:Connect(function()
        					removeSelectedValue(value)
        				end)

        				-- Auto-size chip based on text
        				local textBounds = game:GetService("TextService"):GetTextSize(
        					displayText,
        					chipText.TextSize,
        					chipText.Font,
        					Vector2.new(200, chipText.AbsoluteSize.Y)
        				)
        				local chipWidth = textBounds.X + 32 -- Text width + padding + X button
        				chip.Size = UDim2.new(0, chipWidth, 0, selectHeight - 8)

        				-- Add to total width for canvas sizing
        				totalWidth = totalWidth + chipWidth + 4 -- Include padding
        			end

        			-- Update canvas size for horizontal scrolling
        			chipsContainer.CanvasSize = UDim2.new(0, math.max(totalWidth, chipsContainer.AbsoluteSize.X), 0, 0)
        		else
        			-- Single select mode
        			local displayText = selectedValues[1]
        			for _, option in ipairs(options) do
        				if option.value == selectedValues[1] then
        					displayText = option.text
        					break
        				end
        			end
        			selectButton.Text = "  " .. (displayText or "Unknown")
        			selectButton.TextColor3 = Colors.Text.Primary
        			chipsContainer.Visible = false
        		end
        	end

        	-- Remove a selected value (for chip removal)
        	function removeSelectedValue(value)
        		for i, val in ipairs(selectedValues) do
        			if val == value then
        				table.remove(selectedValues, i)
        				break
        			end
        		end
        		updateDisplayText()
        		refreshOptions()

        		-- Save to configuration
        		if flag then
        			local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
        			settings:SetValue(flag, valueToSave)
        		end

        		callback(selectedValues, value)
        	end

        	-- Show/hide bottom sheet with animation
        	local TweenService = game:GetService("TweenService")

        	local function showBottomSheet()
        		bottomSheetOverlay.Visible = true

        		-- Call OnDropdownOpen callback when dropdown is opened
        		if onDropdownOpen then
        			onDropdownOpen(options, function(newOptions)
        				-- Callback function to update options
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Refresh the options display
        					refreshOptions()
        				end
        			end)
        		end

        		-- Animate overlay fade in
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 0.3}
        		)
        		overlayTween:Play()

        		-- Animate bottom sheet slide up from bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, -bottomSheetHeight - 20)}
        		)
        		sheetTween:Play()

        		-- Animate arrow rotation
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 180}
        		)
        		arrowTween:Play()
        	end

        	local function hideBottomSheet()
        		-- Animate overlay fade out
        		local overlayTween = TweenService:Create(bottomSheetOverlay, 
        			TweenInfo.new(0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{BackgroundTransparency = 1}
        		)

        		-- Animate bottom sheet slide down to bottom of window
        		local sheetTween = TweenService:Create(bottomSheet, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), 
        			{Position = UDim2.new(0, 20, 1, 20)}
        		)

        		-- Animate arrow rotation back
        		local arrowTween = TweenService:Create(arrow, 
        			TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), 
        			{Rotation = 0}
        		)
        		arrowTween:Play()

        		sheetTween:Play()
        		overlayTween:Play()

        		overlayTween.Completed:Connect(function()
        			bottomSheetOverlay.Visible = false
        		end)
        	end

        	local function searchOptions(query)
        		local searchText = query:lower()
        		local visibleCount = 0
        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") then
        				local optionTextLabel = child:FindFirstChild("TextLabel")
        				if optionTextLabel then
        					local optionText = string.lower(optionTextLabel.Text)
        					local isVisible = searchText == "" or string.find(optionText, searchText, 1, true) ~= nil
        					child.Visible = isVisible
        					if isVisible then
        						visibleCount = visibleCount + 1
        					end
        				end
        			end
        		end
        		-- Update scroll canvas size based on visible items
        		local visibleHeight = visibleCount * 50
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, visibleHeight)
        	end

        	-- Create options
        	function refreshOptions()
        		-- Save current search text
        		local searchTextBefore = searchBox and searchBox.Text or ""

        		for _, child in pairs(optionsContainer:GetChildren()) do
        			if child:IsA("TextButton") or child:IsA("UIListLayout") then
        				if child:IsA("TextButton") then
        					child:Destroy()
        				end
        			end
        		end

        		-- Update canvas size for scrolling (smaller option height)
        		local totalHeight = #options * 35
        		optionsContainer.Size = UDim2.new(1, 0, 0, totalHeight)
        		optionsScrollFrame.CanvasSize = UDim2.new(0, 0, 0, totalHeight)

        		-- Update bottom sheet height based on current options count
        		local newBottomSheetHeight = math.min(#options * 35 + 90, bottomSheetMaxHeight)
        		if newBottomSheetHeight ~= bottomSheetHeight then
        			bottomSheetHeight = newBottomSheetHeight
        			bottomSheet.Size = UDim2.new(1, -40, 0, bottomSheetHeight)
        		end

        		for i, option in ipairs(options) do
        			-- Modern option button (smaller)
        			local optionButton = Instance.new("TextButton")
        			optionButton.Size = UDim2.new(1, 0, 0, 35)
        			optionButton.Position = UDim2.new(0, 0, 0, (i-1) * 35)
        			optionButton.BackgroundColor3 = Colors.Surface.Default
        			optionButton.BackgroundTransparency = 0
        			optionButton.BorderSizePixel = 0
        			optionButton.Text = ""
        			optionButton.ZIndex = 103
        			optionButton.Parent = optionsContainer

        			-- Option text (smaller)
        			local optionText = Instance.new("TextLabel")
        			optionText.Size = UDim2.new(1, -48, 1, 0)
        			optionText.Position = UDim2.new(0, 16, 0, 0)
        			optionText.BackgroundTransparency = 1
        			optionText.Text = option.text
        			optionText.TextColor3 = Colors.Text.Primary
        			optionText.TextXAlignment = Enum.TextXAlignment.Left
        			optionText.TextYAlignment = Enum.TextYAlignment.Center
        			optionText.Font = Enum.Font.Gotham
        			optionText.TextSize = 13
        			optionText.ZIndex = 104
        			optionText.Parent = optionButton

        			-- Modern checkmark/selection indicator (smaller)
        			local checkmark = Instance.new("Frame")
        			checkmark.Size = UDim2.new(0, 16, 0, 16)
        			checkmark.Position = UDim2.new(1, -28, 0.5, -8)
        			checkmark.BackgroundColor3 = Colors.Status.Success
        			checkmark.BorderSizePixel = 0
        			checkmark.Visible = false
        			checkmark.ZIndex = 104
        			checkmark.Parent = optionButton

        			local checkCorner = Instance.new("UICorner")
        			checkCorner.CornerRadius = UDim.new(0, 8)
        			checkCorner.Parent = checkmark

        			local checkIcon = Instance.new("TextLabel")
        			checkIcon.Size = UDim2.new(1, 0, 1, 0)
        			checkIcon.BackgroundTransparency = 1
        			checkIcon.Text = "✓"
        			checkIcon.TextColor3 = Color3.fromRGB(255, 255, 255)
        			checkIcon.TextXAlignment = Enum.TextXAlignment.Center
        			checkIcon.TextYAlignment = Enum.TextYAlignment.Center
        			checkIcon.Font = Enum.Font.GothamBold
        			checkIcon.TextSize = 10
        			checkIcon.ZIndex = 105
        			checkIcon.Parent = checkmark

        			-- Check if selected
        			local isSelected = false
        			for _, val in ipairs(selectedValues) do
        				if val == option.value then
        					isSelected = true
        					break
        				end
        			end

        			if isSelected then
        				checkmark.Visible = true
        				optionButton.BackgroundColor3 = Colors.Input.Background
        				optionText.TextColor3 = Colors.Status.Success
        			end

        			-- Hover effect
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Input.Background
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Click handler
        			optionButton.MouseButton1Click:Connect(function()
        				if multiSelect then
        					local found = false
        					for j, val in ipairs(selectedValues) do
        						if val == option.value then
        							table.remove(selectedValues, j)
        							found = true
        							break
        						end
        					end

        					if not found then
        						table.insert(selectedValues, option.value)
        					end

        					refreshOptions()
        				else
        					selectedValues = {option.value}
        					isOpen = false
        					hideBottomSheet()
        				end

        				updateDisplayText()

        				-- Save to configuration
        				if flag then
        					local valueToSave = multiSelect and selectedValues or (selectedValues[1] or "")
        					settings:SetValue(flag, valueToSave)
        				end

        				callback(selectedValues, option.value)
        			end)

        			-- Hover effects
        			optionButton.MouseEnter:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.OptionHover
        				end
        			end)

        			optionButton.MouseLeave:Connect(function()
        				if not isSelected then
        					optionButton.BackgroundColor3 = Colors.Dropdown.Option
        				end
        			end)
        		end

        		-- Restore value search after refresh
        		if searchBox then
        			searchOptions(searchTextBefore)
        		end
        	end

        	-- Toggle bottom sheet
        	local function toggleBottomSheet()
        		isOpen = not isOpen
        		if isOpen then
        			showBottomSheet()
        		else
        			hideBottomSheet()
        		end
        	end

        	-- Button handlers
        	selectButton.MouseButton1Click:Connect(toggleBottomSheet)

        	-- Overlay click to close
        	bottomSheetOverlay.MouseButton1Click:Connect(function()
        		if isOpen then
        			isOpen = false
        			hideBottomSheet()
        		end
        	end)

        	-- Search filter
        	searchBox:GetPropertyChangedSignal("Text"):Connect(function()
        		searchOptions(searchBox.Text)
        	end)

        	-- Initial setup
        	refreshOptions()
        	updateDisplayText()

        	-- SelectBox API
        	local selectBoxAPI = {
        		SelectBox = selectContainer
        	}

        	function selectBoxAPI:GetSelected()
        		return selectedValues
        	end

        	function selectBoxAPI:SetSelected(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Clear()
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Refresh(newOptions)
        		rawOptions = newOptions
        		options = {}
        		for i, option in ipairs(rawOptions) do
        			if type(option) == "string" then
        				table.insert(options, {text = option, value = option})
        			elseif type(option) == "table" and option.text and option.value then
        				table.insert(options, option)
        			end
        		end
        		selectedValues = {}
        		refreshOptions()
        		updateDisplayText()
        	end

        	function selectBoxAPI:Set(values)
        		selectedValues = type(values) == "table" and values or (values ~= "" and {values} or {})
        		updateDisplayText()
        	end

        	function selectBoxAPI:Cleanup()
        		if bottomSheetOverlay then
        			bottomSheetOverlay:Destroy()
        		end
        		if selectContainer then
        			selectContainer:Destroy()
        		end
        	end

        	-- Register component
        	if registerComponent then
        		registerComponent(flag, selectBoxAPI)
        	end

        	-- Execute OnInit callback after component is fully created
        	if onInit and type(onInit) == "function" then
        		-- Preserve selected values before calling onInit
        		local preservedSelectedValues = selectedValues

        		-- Call OnInit with selectBoxAPI and options update function
        		onInit(selectBoxAPI, {
        			currentOptions = options,
        			updateOptions = function(newOptions)
        				-- Callback function to update options on initialization
        				if newOptions and type(newOptions) == "table" then
        					-- Update options with new data
        					rawOptions = newOptions
        					options = {}
        					for i, option in ipairs(rawOptions) do
        						if type(option) == "string" then
        							table.insert(options, {text = option, value = option})
        						elseif type(option) == "table" and option.text and option.value then
        							table.insert(options, option)
        						end
        					end

        					-- Restore selected values after options update
        					selectedValues = preservedSelectedValues

        					-- Refresh the options display
        					refreshOptions()
        					-- Update display text after refreshing options
        					updateDisplayText()
        				end
        			end
        		})
        	end

        	return selectBoxAPI
        end

        return SelectBox

    end

    -- Module: components/separator
    EmbeddedModules["components/separator"] = function()
        --[[
        	Separator Component
        	EzUI Library - Modular Component

        	Creates a horizontal line separator
        ]]
        local Separator = {}

        local Colors

        function Separator:Init(_colors)
        	Colors = _colors
        end

        function Separator:Create(config)
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	local separator = Instance.new("Frame")
        	if isForAccordion then
        		separator.Size = UDim2.new(1, 0, 0, 1)
        		-- Don't set Position for accordion separators - let UIListLayout handle it
        		separator.ZIndex = 5
        	else
        		separator.Size = UDim2.new(1, -20, 0, 1)
        		separator.Position = UDim2.new(0, 10, 0, currentY + 5)
        		separator.ZIndex = 3
        		separator:SetAttribute("ComponentStartY", currentY)
        	end
        	separator.BackgroundColor3 = Colors.Special.Divider
        	separator.BorderSizePixel = 0
        	separator.Parent = parentContainer

        	-- Create Separator API
        	local separatorAPI = {
        		Separator = separator
        	}

        	function separatorAPI:SetColor(color)
        		separator.BackgroundColor3 = color
        	end

        	return separatorAPI
        end

        return Separator

    end

    -- Module: components/textbox
    EmbeddedModules["components/textbox"] = function()
        --[[
        	TextBox Component
        	EzUI Library - Modular Component

        	Creates a text input field with character counter
        ]]
        local TextBox = {}

        local Colors

        function TextBox:Init(_colors)
        	Colors = _colors
        end

        function TextBox:Create(config)
        	local name = config.Name or config.Title or ""
        	local placeholder = config.Placeholder or "Enter text..."
        	local defaultText = config.Default or ""
        	local callback = config.Callback or function() end
        	local maxLength = config.MaxLength or 100
        	local multiline = config.Multiline or false
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Button configuration
        	local buttons = config.Buttons or {} -- Array of button configs: {Text="Submit", Callback=function() end}
        	local hasButtons = #buttons > 0

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- TextBox state
        	local currentText = defaultText

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		else
        		end

        		if flagValue ~= nil then
        			currentText = flagValue
        			defaultText = currentText
        		end
        	end

        		-- Calculate heights based on whether we have a title label
        	local hasTitle = name and name ~= ""
        	local labelHeight = hasTitle and 18 or 0
        	local inputHeight = multiline and (isForAccordion and 60 or 80) or (isForAccordion and 25 or 30)
        	local totalHeight = labelHeight + inputHeight + (hasTitle and 2 or 0) -- 2px spacing between label and input

        	-- Main textbox container
        	local textBoxContainer = Instance.new("Frame")
        	if isForAccordion then
        		textBoxContainer.Size = UDim2.new(1, -10, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 5, 0, currentY)
        		textBoxContainer.ZIndex = 6
        	else
        		textBoxContainer.Size = UDim2.new(1, -20, 0, totalHeight)
        		textBoxContainer.Position = UDim2.new(0, 10, 0, currentY)
        		textBoxContainer.ZIndex = 3
        		textBoxContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	textBoxContainer.BackgroundTransparency = 1
        	textBoxContainer.ClipsDescendants = true -- Ensure text doesn't overflow container
        	textBoxContainer.Parent = parentContainer

        	-- Title label (if name is provided)
        	local titleLabel = nil
        	if hasTitle then
        		titleLabel = Instance.new("TextLabel")
        		titleLabel.Size = UDim2.new(1, 0, 0, labelHeight)
        		titleLabel.Position = UDim2.new(0, 0, 0, 0)
        		titleLabel.BackgroundTransparency = 1
        		titleLabel.Text = name
        		titleLabel.TextColor3 = Colors.Text.Primary
        		titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        		titleLabel.Font = Enum.Font.SourceSans
        		titleLabel.TextSize = isForAccordion and 12 or 14
        		titleLabel.ZIndex = isForAccordion and 7 or 4
        		titleLabel.Parent = textBoxContainer
        	end

        	-- Calculate button width (each button is 80px wide + 5px spacing)
        	local buttonWidth = hasButtons and (#buttons * 85) or 0 -- 80px + 5px spacing per button

        	-- TextBox input
        	local textBox = Instance.new("TextBox")
        	if hasTitle then
        		textBox.Size = UDim2.new(1, -buttonWidth, 0, inputHeight)
        		textBox.Position = UDim2.new(0, 0, 0, labelHeight + 2)
        	else
        		if hasButtons then
        			textBox.Size = UDim2.new(1, -buttonWidth, 1, 0)
        		else
        			textBox.Size = UDim2.new(1, 0, 1, 0)
        		end
        		textBox.Position = UDim2.new(0, 0, 0, 0)
        	end
        	textBox.BackgroundColor3 = Colors.Input.Background
        	textBox.BorderColor3 = Colors.Input.Border
        	textBox.BorderSizePixel = 1
        	textBox.Text = defaultText
        	textBox.PlaceholderText = placeholder
        	textBox.TextColor3 = Colors.Input.Text
        	textBox.PlaceholderColor3 = Colors.Text.Tertiary
        	textBox.Font = Enum.Font.SourceSans
        	textBox.TextSize = isForAccordion and 12 or 14
        	textBox.TextXAlignment = Enum.TextXAlignment.Left
        	textBox.TextYAlignment = multiline and Enum.TextYAlignment.Top or Enum.TextYAlignment.Center
        	textBox.MultiLine = multiline
        	textBox.TextWrapped = multiline
        	textBox.TextScaled = false -- Prevent text from scaling down automatically
        	textBox.ClearTextOnFocus = false
        	textBox.ClipsDescendants = true -- Clip text that overflows the TextBox
        	textBox.ZIndex = isForAccordion and 7 or 4
        	textBox.Parent = textBoxContainer

        	-- Add padding to TextBox
        	local padding = Instance.new("UIPadding")
        	padding.PaddingLeft = UDim.new(0, 8)
        	padding.PaddingRight = UDim.new(0, 8)
        	padding.PaddingTop = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.PaddingBottom = multiline and UDim.new(0, 4) or UDim.new(0, 0)
        	padding.Parent = textBox

        	-- Round corners
        	local corner = Instance.new("UICorner")
        	corner.CornerRadius = UDim.new(0, 4)
        	corner.Parent = textBox

        	-- Character counter (if maxLength is set)
        	local charCounter = nil
        	if maxLength and maxLength > 0 then
        		charCounter = Instance.new("TextLabel")
        		charCounter.Size = UDim2.new(0, 50, 0, 15)
        		charCounter.Position = UDim2.new(1, -55, 1, -18)
        		charCounter.BackgroundTransparency = 1
        		charCounter.Text = string.len(currentText) .. "/" .. maxLength
        		charCounter.TextColor3 = Colors.Text.Tertiary
        		charCounter.Font = Enum.Font.SourceSans
        		charCounter.TextSize = isForAccordion and 10 or 12
        		charCounter.TextXAlignment = Enum.TextXAlignment.Right
        		charCounter.ZIndex = isForAccordion and 8 or 5
        		charCounter.Parent = textBoxContainer
        	end

        	-- Create buttons (if configured)
        	local buttonObjects = {}
        	if hasButtons then
        		local buttonY = hasTitle and (labelHeight + 2) or 0
        		local buttonHeight = inputHeight

        		for i, buttonConfig in ipairs(buttons) do
        			local buttonText = buttonConfig.Text or "Button"
        			local buttonCallback = buttonConfig.Callback or function() end
        			local buttonVariant = buttonConfig.Variant or "primary"

        			-- Calculate button position (buttons are positioned from right to left)
        			local buttonX = (1 - (i * 85 / textBoxContainer.AbsoluteSize.X)) -- 85px per button from right

        			local button = Instance.new("TextButton")
        			button.Size = UDim2.new(0, 80, 0, buttonHeight)
        			button.Position = UDim2.new(1, -i * 85 + 5, 0, buttonY) -- 5px spacing from edge
        			button.BackgroundColor3 = buttonVariant == "primary" and Colors.Accent.Primary or Colors.Surface.Default
        			button.BorderSizePixel = 0
        			button.Text = buttonText
        			button.TextColor3 = buttonVariant == "primary" and Color3.fromRGB(255, 255, 255) or Colors.Text.Primary
        			button.Font = Enum.Font.SourceSans
        			button.TextSize = isForAccordion and 11 or 13
        			button.ZIndex = isForAccordion and 7 or 4
        			button.Parent = textBoxContainer

        			-- Button corner radius
        			local buttonCorner = Instance.new("UICorner")
        			buttonCorner.CornerRadius = UDim.new(0, 4)
        			buttonCorner.Parent = button

        			-- Button hover effects
        			button.MouseEnter:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Hover
        				else
        					button.BackgroundColor3 = Colors.Surface.Hover
        				end
        			end)

        			button.MouseLeave:Connect(function()
        				if buttonVariant == "primary" then
        					button.BackgroundColor3 = Colors.Accent.Primary
        				else
        					button.BackgroundColor3 = Colors.Surface.Default
        				end
        			end)

        			-- Button click handler
        			button.MouseButton1Click:Connect(function()
        				if buttonCallback then
        					buttonCallback(textBox.Text, textBox) -- Pass current text and textBox reference
        				end
        			end)

        			table.insert(buttonObjects, {
        				Button = button,
        				Text = buttonText,
        				Callback = buttonCallback
        			})
        		end
        	end

        	-- Function to update character counter
        	local function updateCharCounter()
        		if charCounter then
        			local textLength = string.len(textBox.Text)
        			charCounter.Text = textLength .. "/" .. maxLength

        			-- Change color based on limit
        			if textLength >= maxLength then
        				charCounter.TextColor3 = Colors.Status.Error
        			elseif textLength >= maxLength * 0.8 then
        				charCounter.TextColor3 = Colors.Status.Warning
        			else
        				charCounter.TextColor3 = Colors.Text.Tertiary
        			end
        		end
        	end

        	-- Text change handler
        	textBox.Changed:Connect(function(property)
        		if property == "Text" then
        			-- Enforce max length
        			if maxLength and maxLength > 0 and string.len(textBox.Text) > maxLength then
        				textBox.Text = string.sub(textBox.Text, 1, maxLength)
        			end

        			currentText = textBox.Text
        			updateCharCounter()

        			-- Save to configuration
        			if flag then
        				settings:SetValue(flag, currentText)
        			end

        			-- Call user callback
        			local success, errorMsg = pcall(function()
        				callback(currentText)
        			end)

        			if not success then
        			end
        		end
        	end)

        	-- Focus effects
        	textBox.Focused:Connect(function()
        		textBox.BorderColor3 = Colors.Input.BorderFocus
        	end)

        	textBox.FocusLost:Connect(function()
        		textBox.BorderColor3 = Colors.Input.Border
        	end)

        	-- Return TextBox API
        	local textBoxAPI = {
        		TextBox = textBoxContainer,
        		Buttons = buttonObjects
        	}

        	function textBoxAPI:GetText()
        		return currentText
        	end

        	function textBoxAPI:SetText(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, currentText)
        		end
        	end

        	function textBoxAPI:Clear()
        		textBox.Text = ""
        		currentText = ""
        		updateCharCounter()
        		-- Save to configuration
        		if flag then
        			-- Check if using custom config object
        			if EzUIConfig and type(EzUIConfig.SetValue) == "function" then
        				EzUIConfig.SetValue(flag, currentText)
        			-- Fallback to EzUI.Flags
        			elseif EzUI and EzUI.Flags then
        				EzUI.Flags[flag] = currentText
        				-- Auto-save if enabled
        				if EzUI.Configuration and EzUI.Configuration.AutoSave and saveConfiguration then
        					saveConfiguration(EzUI.Configuration.FileName)
        				end
        			end
        		end
        	end

        	function textBoxAPI:SetPlaceholder(newPlaceholder)
        		textBox.PlaceholderText = tostring(newPlaceholder or "")
        	end

        	function textBoxAPI:Focus()
        		textBox:CaptureFocus()
        	end

        	function textBoxAPI:Blur()
        		textBox:ReleaseFocus()
        	end

        	function textBoxAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	function textBoxAPI:Set(newText)
        		textBox.Text = tostring(newText or "")
        		currentText = textBox.Text
        		updateCharCounter()
        	end

        	-- Button-related methods
        	function textBoxAPI:GetButton(index)
        		return buttonObjects[index]
        	end

        	function textBoxAPI:SetButtonText(index, newText)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.Text = newText
        			buttonObjects[index].Text = newText
        		end
        	end

        	function textBoxAPI:SetButtonCallback(index, newCallback)
        		if buttonObjects[index] then
        			buttonObjects[index].Callback = newCallback or function() end
        			-- Note: We can't change the connected event, but we update the stored callback
        		end
        	end

        	function textBoxAPI:EnableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0
        			buttonObjects[index].Button.TextTransparency = 0
        		end
        	end

        	function textBoxAPI:DisableButton(index)
        		if buttonObjects[index] then
        			buttonObjects[index].Button.BackgroundTransparency = 0.5
        			buttonObjects[index].Button.TextTransparency = 0.5
        		end
        	end

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, textBoxAPI)
        	end

        	return textBoxAPI
        end

        return TextBox

    end

    -- Module: components/toggle
    EmbeddedModules["components/toggle"] = function()
        --[[
        	Toggle Component
        	EzUI Library - Modular Component

        	Creates a toggle/switch with on/off states
        ]]
        local Toggle = {}

        local Colors

        function Toggle:Init(_colors)
        	Colors = _colors
        end

        function Toggle:Create(config)
        	local text = config.Name or config.Text or "Toggle"
        	local defaultValue = config.Default or false
        	local callback = config.Callback or function() end
        	local flag = config.Flag
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local EzUI = config.EzUI
        	local saveConfiguration = config.SaveConfiguration
        	local registerComponent = config.RegisterComponent
        	local settings = config.Settings

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Toggle state
        	local isToggled = defaultValue

        	-- Load from flag (supports both EzUI.Flags and custom config)
        	if flag then
        		local flagValue = nil

        		-- Check if using custom config object
        		if settings and type(settings.GetValue) == "function" then
        			flagValue = settings:GetValue(flag)
        		end

        		if flagValue ~= nil then
        			isToggled = flagValue
        		end
        	end

        	-- Main toggle container
        	local toggleContainer = Instance.new("Frame")
        	if isForAccordion then
        		toggleContainer.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion toggles - let UIListLayout handle it
        		toggleContainer.ZIndex = 6
        	else
        		toggleContainer.Size = UDim2.new(1, -20, 0, 30)
        		toggleContainer.Position = UDim2.new(0, 10, 0, currentY)
        		toggleContainer.ZIndex = 3
        		toggleContainer:SetAttribute("ComponentStartY", currentY)
        	end
        	toggleContainer.BackgroundTransparency = 1
        	toggleContainer.Parent = parentContainer

        	-- Toggle label
        	local toggleLabel = Instance.new("TextLabel")
        	if isForAccordion then
        		toggleLabel.Size = UDim2.new(1, -45, 1, 0)
        		toggleLabel.TextSize = 12
        		toggleLabel.ZIndex = 7
        	else
        		toggleLabel.Size = UDim2.new(1, -60, 1, 0)
        		toggleLabel.TextSize = 16
        		toggleLabel.ZIndex = 4
        	end
        	toggleLabel.Position = UDim2.new(0, 0, 0, 0)
        	toggleLabel.BackgroundTransparency = 1
        	toggleLabel.Text = text
        	toggleLabel.TextColor3 = Colors.Text.Primary
        	toggleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	toggleLabel.Font = Enum.Font.SourceSans
        	toggleLabel.Parent = toggleContainer

        	-- Toggle switch background
        	local toggleBg = Instance.new("Frame")
        	if isForAccordion then
        		toggleBg.Size = UDim2.new(0, 40, 0, 20)
        		toggleBg.Position = UDim2.new(1, -40, 0.5, -10)
        		toggleBg.ZIndex = 7
        	else
        		toggleBg.Size = UDim2.new(0, 50, 0, 24)
        		toggleBg.Position = UDim2.new(1, -50, 0.5, -12)
        		toggleBg.ZIndex = 4
        	end
        	toggleBg.BackgroundColor3 = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        	toggleBg.BorderSizePixel = 0
        	toggleBg.Parent = toggleContainer

        	-- Round corners for toggle background
        	local toggleBgCorner = Instance.new("UICorner")
        	toggleBgCorner.CornerRadius = UDim.new(0, isForAccordion and 10 or 12)
        	toggleBgCorner.Parent = toggleBg

        	-- Toggle switch button (circle)
        	local toggleButton = Instance.new("TextButton")
        	if isForAccordion then
        		toggleButton.Size = UDim2.new(0, 16, 0, 16)
        		toggleButton.Position = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		toggleButton.ZIndex = 8
        	else
        		toggleButton.Size = UDim2.new(0, 20, 0, 20)
        		toggleButton.Position = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		toggleButton.ZIndex = 5
        	end
        	toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	toggleButton.BorderSizePixel = 0
        	toggleButton.Text = ""
        	toggleButton.Parent = toggleBg

        	-- Round corners for toggle button
        	local toggleButtonCorner = Instance.new("UICorner")
        	toggleButtonCorner.CornerRadius = UDim.new(0, isForAccordion and 8 or 10)
        	toggleButtonCorner.Parent = toggleButton

        	-- Function to update toggle appearance
        	local function updateToggleAppearance()
        		local targetBgColor = isToggled and Colors.Toggle.On or Colors.Toggle.Off
        		local targetPosition

        		if isForAccordion then
        			targetPosition = isToggled and UDim2.new(1, -18, 0.5, -8) or UDim2.new(0, 2, 0.5, -8)
        		else
        			targetPosition = isToggled and UDim2.new(1, -22, 0.5, -10) or UDim2.new(0, 2, 0.5, -10)
        		end

        		-- Animate background color
        		local bgTween = game:GetService("TweenService"):Create(
        			toggleBg,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{BackgroundColor3 = targetBgColor}
        		)
        		bgTween:Play()

        		-- Animate button position
        		local buttonTween = game:GetService("TweenService"):Create(
        			toggleButton,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Position = targetPosition}
        		)
        		buttonTween:Play()
        	end

        	-- Toggle click handler
        	local function handleToggle()
        		isToggled = not isToggled
        		updateToggleAppearance()

        		-- Save to configuration
        		if flag then
        			settings:SetValue(flag, isToggled)
        		end

        		-- Call user callback
        		local success, errorMsg = pcall(function()
        			callback(isToggled)
        		end)

        		if not success then
        		end
        	end

        	toggleButton.MouseButton1Click:Connect(handleToggle)

        	-- Also allow clicking the background to toggle
        	toggleBg.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 then
        			handleToggle()
        		end
        	end)

        	-- Hover effects
        	toggleButton.MouseEnter:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	toggleButton.MouseLeave:Connect(function()
        		toggleButton.BackgroundColor3 = Colors.Toggle.Handle
        	end)

        	-- Return Toggle API
        	local toggleAPI = {
        		Toggle = toggleContainer
        	}

        	function toggleAPI:SetValue(newValue)
        		if type(newValue) ~= "boolean" and newValue == isToggled then
        			return
        		end

        		isToggled = newValue
        		updateToggleAppearance()

        		-- Save to configuration
        		if not flag then
        			return
        		end

        		settings:SetValue(flag, isToggled)
        	end

        	function toggleAPI:GetValue()
        		return isToggled
        	end

        	function toggleAPI:SetText(newText)
        		text = newText
        		toggleLabel.Text = newText
        	end

        	function toggleAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        	end

        	toggleAPI.Set = toggleAPI.SetValue

        	-- Register component for flag-based updates
        	if registerComponent then
        		registerComponent(flag, toggleAPI)
        	end

        	return toggleAPI
        end

        return Toggle

    end

    -- Module: components/window
    EmbeddedModules["components/window"] = function()
        --[[
        	Window Component
        	EzUI Library - Modular Component

        	Creates main window with responsive sizing and dragging
        ]]

        local Window = {}
        local Colors
        local Accordion
        local Button
        local Label
        local NumberBox
        local Notification
        local SelectBox
        local Separator
        local Tab
        local TextBox
        local Toggle

        function Window:Init(_colors, _accordion, _button, _label, _numberbox, _notification, _selectbox, _separator, _tab, _textbox, _toggle)
            Colors = _colors
            Accordion = _accordion
            Button = _button
            Label = _label
            NumberBox = _numberbox
            Notification = _notification
            SelectBox = _selectbox
            Separator = _separator
            Tab = _tab
            TextBox = _textbox
            Toggle = _toggle

            -- Debug: Verify Colors module is loaded
            if not Colors then
            elseif not Colors.Background then
            end
        end

        function Window:GetViewportSize()
        	local camera = workspace.CurrentCamera
        	if not camera then
        		camera = workspace:WaitForChild("CurrentCamera", 5)
        	end

        	local viewportSize = camera.ViewportSize

        	if viewportSize.X <= 1 or viewportSize.Y <= 1 then
        		viewportSize = Vector2.new(1366, 768)
        	end

        	return viewportSize
        end

        function Window:CalculateDynamicSize(width, height)
        	local viewportSize = self:GetViewportSize()

        	local baseWidth = width or (viewportSize.X * 0.7)
        	local baseHeight = height or (viewportSize.Y * 0.4)

        	local scaleMultiplier = 1
        	if viewportSize.X >= 1920 then
        		scaleMultiplier = 1.2
        	elseif viewportSize.X >= 1366 then
        		scaleMultiplier = 1.0
        	elseif viewportSize.X >= 1024 then
        		scaleMultiplier = 0.9
        	else
        		scaleMultiplier = 0.8
        	end

        	local finalWidth = math.max(300, math.min(viewportSize.X * 0.8, baseWidth * scaleMultiplier))
        	local finalHeight = math.max(200, math.min(viewportSize.Y * 0.8, baseHeight * scaleMultiplier))

        	return finalWidth, finalHeight
        end

        function Window:CreateFloatingButton(screenGui, frame, toggleMinimizeCallback, autoShow)
        	-- Create floating button (visibility based on AutoShow parameter)
        	local floatingButton = Instance.new("Frame")
        	floatingButton.Size = UDim2.new(0, 50, 0, 50)
        	floatingButton.Position = UDim2.new(0, 0, 0.5, -25) -- Middle left by default
        	floatingButton.BackgroundColor3 = Colors.Background.Primary
        	floatingButton.BorderSizePixel = 0
        	floatingButton.ZIndex = 100
        	floatingButton.Visible = not autoShow -- Show floating button if window starts hidden
        	floatingButton.Active = true
        	floatingButton.Parent = screenGui

        	-- Rounded corners for floating button
        	local floatingCorner = Instance.new("UICorner")
        	floatingCorner.CornerRadius = UDim.new(0, 12)
        	floatingCorner.Parent = floatingButton

        	-- Arrow icon
        	local arrowIcon = Instance.new("TextLabel")
        	arrowIcon.Size = UDim2.new(1, 0, 1, 0)
        	arrowIcon.Position = UDim2.new(0, 0, 0, 0)
        	arrowIcon.BackgroundTransparency = 1
        	arrowIcon.Text = ">"
        	arrowIcon.TextColor3 = Colors.Text.Primary
        	arrowIcon.TextSize = 24
        	arrowIcon.Font = Enum.Font.SourceSansBold
        	arrowIcon.TextXAlignment = Enum.TextXAlignment.Center
        	arrowIcon.TextYAlignment = Enum.TextYAlignment.Center
        	arrowIcon.ZIndex = 101
        	arrowIcon.Parent = floatingButton

        	-- Click detector for floating button
        	local floatingClickButton = Instance.new("TextButton")
        	floatingClickButton.Size = UDim2.new(1, 0, 1, 0)
        	floatingClickButton.BackgroundTransparency = 1
        	floatingClickButton.Text = ""
        	floatingClickButton.ZIndex = 102
        	floatingClickButton.Parent = floatingButton

        	-- Shadow effect for floating button
        	local floatingShadow = Instance.new("Frame")
        	floatingShadow.Size = UDim2.new(1, 4, 1, 4)
        	floatingShadow.Position = UDim2.new(0, -2, 0, -2)
        	floatingShadow.BackgroundColor3 = Colors.Background.Overlay
        	floatingShadow.BackgroundTransparency = 0.8
        	floatingShadow.BorderSizePixel = 0
        	floatingShadow.ZIndex = 99
        	floatingShadow.Parent = floatingButton

        	local shadowCorner = Instance.new("UICorner")
        	shadowCorner.CornerRadius = UDim.new(0, 12)
        	shadowCorner.Parent = floatingShadow

        	-- Hover effects for floating button
        	local originalColor = Colors.Background.Primary
        	floatingClickButton.MouseEnter:Connect(function()
        		floatingButton.BackgroundColor3 = Colors.Background.Secondary
        	end)

        	floatingClickButton.MouseLeave:Connect(function()
        		floatingButton.BackgroundColor3 = originalColor
        	end)

        	-- Dragging functionality for floating button
        	local floatingDragging = false
        	local floatingDragInput, floatingDragStart, floatingStartPos
        	local isOnLeftSide = true -- Track which side the button is on

        	local function snapFloatingButton()
        		-- Get viewport size
        		local viewportSize = Window:GetViewportSize()
        		local currentPos = floatingButton.AbsolutePosition
        		local buttonWidth = floatingButton.AbsoluteSize.X
        		local buttonHeight = floatingButton.AbsoluteSize.Y

        		-- Determine which side is closer (left or right)
        		local distanceToLeft = currentPos.X
        		local distanceToRight = viewportSize.X - (currentPos.X + buttonWidth)

        		local targetX, targetY
        		local offsetAmount = 15 -- How much to offset off-screen

        		if distanceToLeft < distanceToRight then
        			-- Snap to left side - slightly off-screen
        			targetX = -offsetAmount
        			isOnLeftSide = true
        			arrowIcon.Text = ">"
        		else
        			-- Snap to right side - slightly off-screen
        			targetX = viewportSize.X - buttonWidth + offsetAmount
        			isOnLeftSide = false
        			arrowIcon.Text = "<"
        		end

        		-- Keep Y position but clamp to viewport bounds
        		targetY = math.max(10, math.min(viewportSize.Y - buttonHeight - 10, currentPos.Y))

        		-- Animate to snapped position
        		floatingButton:TweenPosition(
        			UDim2.new(0, targetX, 0, targetY),
        			Enum.EasingDirection.Out,
        			Enum.EasingStyle.Quad,
        			0.3,
        			true
        		)
        	end

        	local function updateFloatingDrag(input)
        		local delta = input.Position - floatingDragStart
        		local newPos = UDim2.new(
        			floatingStartPos.X.Scale,
        			floatingStartPos.X.Offset + delta.X,
        			floatingStartPos.Y.Scale,
        			floatingStartPos.Y.Offset + delta.Y
        		)
        		floatingButton.Position = newPos
        	end

        	floatingClickButton.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragging = true
        			floatingDragStart = input.Position
        			floatingStartPos = floatingButton.Position

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					floatingDragging = false
        					-- Snap to nearest side when drag ends
        					pcall(snapFloatingButton)
        				end
        			end)
        		end
        	end)

        	floatingClickButton.InputChanged:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseMovement or
        		   input.UserInputType == Enum.UserInputType.Touch then
        			floatingDragInput = input
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if floatingDragging and input == floatingDragInput then
        			updateFloatingDrag(input)
        		end
        	end)

        	-- Click detection for restore window
        	local clickStartTime = 0
        	local clickStartPos = Vector2.new(0, 0)

        	floatingClickButton.MouseButton1Down:Connect(function()
        		clickStartTime = tick()
        		clickStartPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        	end)

        	floatingClickButton.MouseButton1Up:Connect(function()
        		local clickDuration = tick() - clickStartTime
        		local currentPos = Vector2.new(floatingButton.AbsolutePosition.X, floatingButton.AbsolutePosition.Y)
        		local dragDistance = (currentPos - clickStartPos).Magnitude

        		-- Only toggle if it was a quick click (< 0.2s) and minimal drag (< 5 pixels)
        		if clickDuration < 0.2 and dragDistance < 5 then
        			toggleMinimizeCallback()
        		end
        	end)

        	return {
        		Frame = floatingButton,
        		SnapToEdge = snapFloatingButton
        	}
        end

        function Window:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	local isMinimized = false

        	local function toggleMinimize()
        		isMinimized = not isMinimized

        		if isMinimized then
        			-- Minimize: hide window and show floating button
        			originalPosition = frame.Position
        			frame.Visible = false

        			-- Show floating button with animation
        			floatingButton.Frame.Visible = true
        			floatingButton.Frame.Size = UDim2.new(0, 0, 0, 50)
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 50, 0, 50),
        				Enum.EasingDirection.Out,
        				Enum.EasingStyle.Quad,
        				0.3,
        				true,
        				function()
        					-- Snap to side after appearing
        					floatingButton.SnapToEdge()
        				end
        			)
        		else
        			-- Restore: hide floating button and show window
        			floatingButton.Frame:TweenSize(
        				UDim2.new(0, 0, 0, 50),
        				Enum.EasingDirection.In,
        				Enum.EasingStyle.Quad,
        				0.2,
        				true,
        				function()
        					floatingButton.Frame.Visible = false
        					frame.Visible = true
        					frame.Position = originalPosition
        				end
        			)
        		end
        	end

        	return {
        		Toggle = toggleMinimize,
        		IsMinimized = function() return isMinimized end
        	}
        end

        function Window:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	-- Create resize handle in bottom-right corner
        	local resizeHandle = Instance.new("ImageButton")
        	resizeHandle.Size = UDim2.new(0, 20, 0, 20)
        	resizeHandle.Position = UDim2.new(1, -20, 1, -20)
        	resizeHandle.BackgroundColor3 = Colors.Accent.Primary
        	resizeHandle.BackgroundTransparency = 0.7
        	resizeHandle.BorderSizePixel = 0
            resizeHandle.Image = "rbxassetid://16898613613"
            resizeHandle.ImageRectOffset = Vector2.new(820,196)
        	resizeHandle.ImageRectSize = Vector2.new(48, 48) 
        	resizeHandle.ZIndex = 10
        	resizeHandle.Active = true
        	resizeHandle.Parent = frame

        	-- Corner radius
        	local handleCorner = Instance.new("UICorner")
        	handleCorner.CornerRadius = UDim.new(0, 4)
        	handleCorner.Parent = resizeHandle

        	-- Hover effect
        	resizeHandle.MouseEnter:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.3
        	end)

        	resizeHandle.MouseLeave:Connect(function()
        		resizeHandle.BackgroundTransparency = 0.7
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startSize

        	resizeHandle.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startSize = frame.AbsoluteSize

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new size
        			local newWidth = startSize.X + delta.X
        			local newHeight = startSize.Y + delta.Y

        			-- Apply min/max constraints
        			newWidth = math.max(minWidth or 300, newWidth)
        			newHeight = math.max(minHeight or 200, newHeight)

        			if maxWidth then
        				newWidth = math.min(maxWidth, newWidth)
        			end

        			if maxHeight then
        				newHeight = math.min(maxHeight, newHeight)
        			end

        			-- Update frame size
        			frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		end
        	end)

        	return resizeHandle
        end

        function Window:CreateTabPanelResizer(tabPanel, scrollFrame, minTabWidth, maxTabWidth)
        	-- Create resize handle on right edge of tab panel
        	local resizer = Instance.new("Frame")
        	resizer.Size = UDim2.new(0, 4, 1, 0)
        	resizer.Position = UDim2.new(1, 0, 0, 0)
        	resizer.BackgroundColor3 = Colors.Accent.Primary
        	resizer.BackgroundTransparency = 0.9
        	resizer.BorderSizePixel = 0
        	resizer.ZIndex = 10
        	resizer.Active = true
        	resizer.Parent = tabPanel

        	-- Visual indicator (appears on hover)
        	local indicator = Instance.new("Frame")
        	indicator.Size = UDim2.new(0, 2, 1, 0)
        	indicator.Position = UDim2.new(0, 1, 0, 0)
        	indicator.BackgroundColor3 = Colors.Accent.Primary
        	indicator.BackgroundTransparency = 1
        	indicator.BorderSizePixel = 0
        	indicator.ZIndex = 11
        	indicator.Parent = resizer

        	-- Hover effects
        	resizer.MouseEnter:Connect(function()
        		resizer.BackgroundTransparency = 0.7
        		indicator.BackgroundTransparency = 0
        	end)

        	resizer.MouseLeave:Connect(function()
        		resizer.BackgroundTransparency = 0.9
        		indicator.BackgroundTransparency = 1
        	end)

        	-- Resize functionality
        	local resizing = false
        	local resizeStart, startWidth

        	resizer.InputBegan:Connect(function(input)
        		if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        		   input.UserInputType == Enum.UserInputType.Touch then
        			resizing = true
        			resizeStart = input.Position
        			startWidth = tabPanel.AbsoluteSize.X

        			-- Show indicator while resizing
        			indicator.BackgroundTransparency = 0

        			input.Changed:Connect(function()
        				if input.UserInputState == Enum.UserInputState.End then
        					resizing = false
        					indicator.BackgroundTransparency = 1
        				end
        			end)
        		end
        	end)

        	game:GetService("UserInputService").InputChanged:Connect(function(input)
        		if resizing and (input.UserInputType == Enum.UserInputType.MouseMovement or 
        		   input.UserInputType == Enum.UserInputType.Touch) then
        			local delta = input.Position - resizeStart

        			-- Calculate new width
        			local newWidth = startWidth + delta.X

        			-- Apply constraints
        			newWidth = math.max(minTabWidth or 80, newWidth)
        			newWidth = math.min(maxTabWidth or 300, newWidth)

        			-- Update tab panel width
        			tabPanel.Size = UDim2.new(0, newWidth, 1, -30)

        			-- Update scroll frame position and size
        			scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        			scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        		end
        	end)

        	return resizer
        end

        function Window:Create(config)
        	-- Ensure Colors is initialized with detailed error
        	if not Colors then
        		error("Window:Create() - Colors module is nil. Window:Init() may not have been called or Colors parameter was nil.")
        	end

        	if not Colors.Background then
        		error("Window:Create() - Colors.Background is nil. The Colors module may not have loaded correctly.")
        	end

        	local title = config.Title or "EzUI Window"
        	local width = config.Width
        	local height = config.Height
        	local opacity = config.Opacity or 0.9
        	local autoShow = config.AutoShow ~= nil and config.AutoShow or true
        	local draggable = config.Draggable ~= nil and config.Draggable or true
        	local resizable = config.Resizable ~= nil and config.Resizable or true
        	local tabPanelResizable = config.TabPanelResizable ~= nil and config.TabPanelResizable or true
        	local backgroundColor = config.BackgroundColor or Colors.Background.Secondary
        	local cornerRadius = config.CornerRadius or 8
        	local minWidth = config.MinWidth or 300
        	local minHeight = config.MinHeight or 200
        	local maxWidth = config.MaxWidth
        	local maxHeight = config.MaxHeight
        	local tabPanelWidth = config.TabPanelWidth or 130
        	local minTabPanelWidth = config.MinTabPanelWidth or 80
        	local maxTabPanelWidth = config.MaxTabPanelWidth or 300
        	local settings = config.Settings or {}
        	local autoAdapt = config.AutoAdapt ~= nil and config.AutoAdapt or true

        	-- Close callback functionality
        	local onCloseCallback = config.OnClose or nil

        	opacity = math.max(0.1, math.min(1.0, opacity))

        	local screenGui = Instance.new("ScreenGui")
        	screenGui.Name = title
        	screenGui.ResetOnSpawn = false
        	screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")

        	local windowWidth, windowHeight = self:CalculateDynamicSize(width, height)

        	-- Main window frame
        	local frame = Instance.new("Frame")
        	frame.Size = UDim2.new(0, windowWidth, 0, windowHeight)
        	frame.Position = UDim2.new(0.5, -windowWidth / 2, 0.5, -windowHeight / 2)
        	frame.BackgroundColor3 = backgroundColor
        	frame.BackgroundTransparency = 1 - opacity
        	frame.BorderSizePixel = 0
        	frame.Active = true
        	frame.ClipsDescendants = true
        	frame.ZIndex = 1
        	frame.Visible = autoShow
        	frame.Parent = screenGui

        	-- Rounded corners
        	local frameCorner = Instance.new("UICorner")
        	frameCorner.CornerRadius = UDim.new(0, cornerRadius)
        	frameCorner.Parent = frame

        	-- Title bar
        	local titleBar = Instance.new("Frame")
        	titleBar.Size = UDim2.new(1, 0, 0, 30)
        	titleBar.Position = UDim2.new(0, 0, 0, 0)
        	titleBar.BackgroundColor3 = Colors.Background.Primary
        	titleBar.BorderSizePixel = 0
        	titleBar.ZIndex = 2
        	titleBar.Parent = frame

        	-- Title bar rounded corners (top only)
        	local titleCorner = Instance.new("UICorner")
        	titleCorner.CornerRadius = UDim.new(0, cornerRadius)
        	titleCorner.Parent = titleBar

        	-- Title text
        	local titleLabel = Instance.new("TextLabel")
        	titleLabel.Size = UDim2.new(1, -70, 1, 0)
        	titleLabel.Position = UDim2.new(0, 10, 0, 0)
        	titleLabel.BackgroundTransparency = 1
        	titleLabel.Text = title
        	titleLabel.TextColor3 = Colors.Text.Primary
        	titleLabel.TextSize = 16
        	titleLabel.Font = Enum.Font.SourceSansBold
        	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
        	titleLabel.ZIndex = 3
        	titleLabel.Parent = titleBar

        	-- Minimize button
        	local minimizeBtn = Instance.new("TextButton")
        	minimizeBtn.Size = UDim2.new(0, 30, 0, 30)
        	minimizeBtn.Position = UDim2.new(1, -60, 0, 0)
        	minimizeBtn.BackgroundTransparency = 1
        	minimizeBtn.Text = "−"
        	minimizeBtn.TextColor3 = Colors.Text.Primary
        	minimizeBtn.TextSize = 24
        	minimizeBtn.Font = Enum.Font.SourceSansBold
        	minimizeBtn.ZIndex = 3
        	minimizeBtn.Parent = titleBar

        	minimizeBtn.MouseEnter:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Accent.Primary
        	end)

        	minimizeBtn.MouseLeave:Connect(function()
        		minimizeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Close button
        	local closeBtn = Instance.new("TextButton")
        	closeBtn.Size = UDim2.new(0, 30, 0, 30)
        	closeBtn.Position = UDim2.new(1, -30, 0, 0)
        	closeBtn.BackgroundTransparency = 1
        	closeBtn.Text = "×"
        	closeBtn.TextColor3 = Colors.Text.Primary
        	closeBtn.TextSize = 24
        	closeBtn.Font = Enum.Font.SourceSansBold
        	closeBtn.ZIndex = 3
        	closeBtn.Parent = titleBar

        	closeBtn.MouseEnter:Connect(function()
        		closeBtn.TextColor3 = Colors.Status.Error
        	end)

        	closeBtn.MouseLeave:Connect(function()
        		closeBtn.TextColor3 = Colors.Text.Primary
        	end)

        	-- Create confirmation dialog elements (hidden by default)
        	local confirmationOverlay = Instance.new("Frame")
        	confirmationOverlay.Size = UDim2.new(1, 0, 1, 0)
        	confirmationOverlay.Position = UDim2.new(0, 0, 0, 0)
        	confirmationOverlay.BackgroundColor3 = Colors.Special.Overlay
        	confirmationOverlay.BackgroundTransparency = 0.5
        	confirmationOverlay.BorderSizePixel = 0
        	confirmationOverlay.ZIndex = 100
        	confirmationOverlay.Visible = false
        	confirmationOverlay.Parent = frame

        	local confirmationDialog = Instance.new("Frame")
        	confirmationDialog.Size = UDim2.new(0, 300, 0, 130)
        	confirmationDialog.Position = UDim2.new(0.5, -150, 0.5, -65)
        	confirmationDialog.BackgroundColor3 = Colors.Surface.Elevated
        	confirmationDialog.BorderSizePixel = 0
        	confirmationDialog.ZIndex = 101
        	confirmationDialog.Parent = confirmationOverlay

        	local confirmDialogCorner = Instance.new("UICorner")
        	confirmDialogCorner.CornerRadius = UDim.new(0, 8)
        	confirmDialogCorner.Parent = confirmationDialog

        	-- Confirmation dialog title
        	local confirmTitle = Instance.new("TextLabel")
        	confirmTitle.Size = UDim2.new(1, -20, 0, 25)
        	confirmTitle.Position = UDim2.new(0, 10, 0, 8)
        	confirmTitle.BackgroundTransparency = 1
        	confirmTitle.Text = "⚠️ Confirm Close"
        	confirmTitle.TextColor3 = Colors.Text.Primary
        	confirmTitle.TextSize = 14
        	confirmTitle.Font = Enum.Font.GothamBold
        	confirmTitle.TextXAlignment = Enum.TextXAlignment.Left
        	confirmTitle.ZIndex = 102
        	confirmTitle.Parent = confirmationDialog

        	-- Confirmation message
        	local confirmMessage = Instance.new("TextLabel")
        	confirmMessage.Size = UDim2.new(1, -20, 0, 35)
        	confirmMessage.Position = UDim2.new(0, 10, 0, 35)
        	confirmMessage.BackgroundTransparency = 1
        	confirmMessage.Text = "Are you sure you want to close?"
        	confirmMessage.TextColor3 = Colors.Text.Secondary
        	confirmMessage.TextSize = 12
        	confirmMessage.Font = Enum.Font.Gotham
        	confirmMessage.TextWrapped = true
        	confirmMessage.TextXAlignment = Enum.TextXAlignment.Left
        	confirmMessage.TextYAlignment = Enum.TextYAlignment.Top
        	confirmMessage.ZIndex = 102
        	confirmMessage.Parent = confirmationDialog

        	-- Button container
        	local buttonContainer = Instance.new("Frame")
        	buttonContainer.Size = UDim2.new(1, -20, 0, 32)
        	buttonContainer.Position = UDim2.new(0, 10, 1, -40)
        	buttonContainer.BackgroundTransparency = 1
        	buttonContainer.ZIndex = 102
        	buttonContainer.Parent = confirmationDialog

        	-- Cancel button
        	local cancelBtn = Instance.new("TextButton")
        	cancelBtn.Size = UDim2.new(0, 130, 0, 32)
        	cancelBtn.Position = UDim2.new(0, 0, 0, 0)
        	cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	cancelBtn.BorderSizePixel = 0
        	cancelBtn.Text = "Cancel"
        	cancelBtn.TextColor3 = Colors.Text.Primary
        	cancelBtn.TextSize = 13
        	cancelBtn.Font = Enum.Font.GothamBold
        	cancelBtn.ZIndex = 103
        	cancelBtn.Parent = buttonContainer

        	local cancelCorner = Instance.new("UICorner")
        	cancelCorner.CornerRadius = UDim.new(0, 6)
        	cancelCorner.Parent = cancelBtn

        	-- Confirm button
        	local confirmBtn = Instance.new("TextButton")
        	confirmBtn.Size = UDim2.new(0, 130, 0, 32)
        	confirmBtn.Position = UDim2.new(1, -130, 0, 0)
        	confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	confirmBtn.BorderSizePixel = 0
        	confirmBtn.Text = "Close"
        	confirmBtn.TextColor3 = Colors.Text.Primary
        	confirmBtn.TextSize = 13
        	confirmBtn.Font = Enum.Font.GothamBold
        	confirmBtn.ZIndex = 103
        	confirmBtn.Parent = buttonContainer

        	local confirmCorner = Instance.new("UICorner")
        	confirmCorner.CornerRadius = UDim.new(0, 6)
        	confirmCorner.Parent = confirmBtn

        	-- Button hover effects
        	cancelBtn.MouseEnter:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.SecondaryHover
        	end)

        	cancelBtn.MouseLeave:Connect(function()
        		cancelBtn.BackgroundColor3 = Colors.Button.Secondary
        	end)

        	confirmBtn.MouseEnter:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.DangerHover
        	end)

        	confirmBtn.MouseLeave:Connect(function()
        		confirmBtn.BackgroundColor3 = Colors.Button.Danger
        	end)

        	-- Cancel button action
        	cancelBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false
        	end)

        	-- Confirm button action
        	confirmBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = false

        		-- Call user close callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        			end
        		end

        		screenGui:Destroy()
        	end)

        	-- Close button shows confirmation dialog
        	closeBtn.MouseButton1Click:Connect(function()
        		confirmationOverlay.Visible = true
        	end)

        	-- Tab panel (left side)
        	local tabPanel = Instance.new("Frame")
        	tabPanel.Size = UDim2.new(0, tabPanelWidth, 1, -30)
        	tabPanel.Position = UDim2.new(0, 0, 0, 30)
        	tabPanel.BackgroundColor3 = Colors.Background.Primary
        	tabPanel.BorderSizePixel = 0
        	tabPanel.ZIndex = 2
        	tabPanel.Parent = frame

        	-- Tab scroll frame
        	local tabScrollFrame = Instance.new("ScrollingFrame")
        	tabScrollFrame.Size = UDim2.new(1, 0, 1, 0)
        	tabScrollFrame.Position = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.BackgroundTransparency = 1
        	tabScrollFrame.BorderSizePixel = 0
        	tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	tabScrollFrame.ScrollBarThickness = 6
        	tabScrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	tabScrollFrame.ZIndex = 3
        	tabScrollFrame.Parent = tabPanel

        	-- List layout for tabs
        	local tabListLayout = Instance.new("UIListLayout")
        	tabListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	tabListLayout.Padding = UDim.new(0, 3)
        	tabListLayout.Parent = tabScrollFrame

        	-- Content scroll frame
        	local scrollFrame = Instance.new("ScrollingFrame")
        	scrollFrame.Size = UDim2.new(1, -tabPanelWidth, 1, -30)
        	scrollFrame.Position = UDim2.new(0, tabPanelWidth, 0, 30)
        	scrollFrame.BackgroundTransparency = 1
        	scrollFrame.BorderSizePixel = 0
        	scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        	scrollFrame.ScrollBarThickness = 8
        	scrollFrame.ScrollBarImageColor3 = Colors.Scrollbar.Thumb
        	scrollFrame.ClipsDescendants = true
        	scrollFrame.ZIndex = 2
        	scrollFrame.Parent = frame

        	-- Function to update canvas size (USING OLD UI.LUA LOGIC - Line ~692)
        	local updateCanvasSize  -- Forward declaration

        	updateCanvasSize = function()
        		-- Calculate actual content height for the active tab only
        		local maxY = 10

        		-- Find the currently visible tab content frame
        		local activeTabContent = nil
        		for _, child in ipairs(scrollFrame:GetChildren()) do
        			if child:IsA("Frame") and child.Visible then
        				activeTabContent = child
        				break
        			end
        		end

        		if activeTabContent then
        			-- Calculate content height within the active tab
        			for _, child in ipairs(activeTabContent:GetChildren()) do
        				if child:IsA("GuiObject") and child.Visible then
        					local childY = child.Position.Y.Offset
        					local childHeight = child.AbsoluteSize.Y
        					local childBottom = childY + childHeight

        					if childBottom > maxY then
        						maxY = childBottom
        					end
        				end
        			end
        		end

        		-- Set canvas size with padding
        		scrollFrame.CanvasSize = UDim2.new(0, 0, 0, maxY + 20)
        	end

        	-- Dragging functionality
        	if draggable then
        		local dragging = false
        		local dragInput, dragStart, startPos

        		local function update(input)
        			local delta = input.Position - dragStart
        			frame.Position = UDim2.new(
        				startPos.X.Scale,
        				startPos.X.Offset + delta.X,
        				startPos.Y.Scale,
        				startPos.Y.Offset + delta.Y
        			)
        		end

        		titleBar.InputBegan:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseButton1 or 
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragging = true
        				dragStart = input.Position
        				startPos = frame.Position

        				input.Changed:Connect(function()
        					if input.UserInputState == Enum.UserInputState.End then
        						dragging = false
        					end
        				end)
        			end
        		end)

        		titleBar.InputChanged:Connect(function(input)
        			if input.UserInputType == Enum.UserInputType.MouseMovement or
        			   input.UserInputType == Enum.UserInputType.Touch then
        				dragInput = input
        			end
        		end)

        		game:GetService("UserInputService").InputChanged:Connect(function(input)
        			if dragging and input == dragInput then
        				update(input)
        			end
        		end)
        	end

        	-- Resize functionality
        	local resizeHandle = nil
        	if resizable then
        		resizeHandle = self:CreateResizeHandle(frame, minWidth, minHeight, maxWidth, maxHeight)
        	end

        	-- Tab panel resize functionality
        	local tabPanelResizer = nil
        	if tabPanelResizable then
        		tabPanelResizer = self:CreateTabPanelResizer(tabPanel, scrollFrame, minTabPanelWidth, maxTabPanelWidth)
        	end

        	-- Monitor frame size changes and update canvas
        	frame:GetPropertyChangedSignal("AbsoluteSize"):Connect(function()
        		-- Update canvas size when window is resized
        		task.spawn(updateCanvasSize)
        	end)

        	-- Tab management
        	local tabs = {}
        	local tabContents = {}
        	local currentTab = nil
        	local tabCount = 0
        	local originalHeight = windowHeight
        	local originalPosition = frame.Position

        	-- Setup minimize/restore functionality (create control first)
        	local minimizeControl = {
        		Toggle = nil,
        		IsMinimized = nil
        	}

        	-- Create floating button with toggle callback
        	local floatingButton = self:CreateFloatingButton(screenGui, frame, function()
        		if minimizeControl.Toggle then
        			minimizeControl.Toggle()
        		end
        	end, autoShow)

        	-- Now create the actual minimize control
        	local actualMinimizeControl = self:SetupMinimizeToggle(frame, floatingButton, originalPosition)
        	minimizeControl.Toggle = actualMinimizeControl.Toggle
        	minimizeControl.IsMinimized = actualMinimizeControl.IsMinimized

        	-- Connect minimize button
        	minimizeBtn.MouseButton1Click:Connect(minimizeControl.Toggle)

        	-- Keyboard shortcut for toggle minimize (Ctrl + M or Ctrl + H)
        	local UserInputService = game:GetService("UserInputService")
        	UserInputService.InputBegan:Connect(function(input, gameProcessed)
        		-- Don't trigger if user is typing in a text box
        		if gameProcessed then return end

        		-- Check for Ctrl + M or Ctrl + H
        		if input.KeyCode == Enum.KeyCode.M or input.KeyCode == Enum.KeyCode.H then
        			if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) or 
        			   UserInputService:IsKeyDown(Enum.KeyCode.RightControl) then
        				minimizeControl.Toggle()
        			end
        		end
        	end)

        	-- Initialize Notification component
        	if Notification then
        		Notification:Init(Colors)
        	end

        	-- Window API
        	local windowAPI = {
        		ScreenGui = screenGui,
        		Frame = frame,
        		TitleBar = titleBar,
        		TabScrollFrame = tabScrollFrame,
        		ScrollFrame = scrollFrame,
        		TabPanel = tabPanel,
        		FloatingButton = floatingButton.Frame,
        		ResizeHandle = resizeHandle,
        		TabPanelResizer = tabPanelResizer,
        		UpdateCanvasSize = updateCanvasSize,  -- Expose update function for accordion callbacks
        		Notification = Notification, -- Expose notification component
        	}

        	function windowAPI:Show()
        		-- Show the window
        		frame.Visible = true
        		-- Hide the floating button when window is shown
        		floatingButton.Frame.Visible = false
        		-- If window was minimized, restore it
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Hide()
        		-- Hide the window
        		frame.Visible = false
        		-- Show the floating button when window is hidden
        		floatingButton.Frame.Visible = true
        	end

        	function windowAPI:IsVisible()
        		-- Check if the window is currently visible (not minimized)
        		return frame.Visible and not minimizeControl.IsMinimized()
        	end

        	function windowAPI:ToggleVisibility()
        		-- Toggle window visibility
        		if self:IsVisible() then
        			self:Hide()
        		else
        			self:Show()
        		end
        		return self:IsVisible()
        	end

        	function windowAPI:Toggle()
        		return self:ToggleVisibility()
        	end

        	function windowAPI:Minimize()
        		if not minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:Restore()
        		if minimizeControl.IsMinimized() then
        			minimizeControl.Toggle()
        		end
        	end

        	function windowAPI:ToggleMinimize()
        		minimizeControl.Toggle()
        	end

        	function windowAPI:IsMinimized()
        		return minimizeControl.IsMinimized()
        	end

        	function windowAPI:Destroy()
        		screenGui:Destroy()
        	end

        	function windowAPI:SetTitle(newTitle)
        		titleLabel.Text = newTitle
        		title = newTitle
        	end

        	function windowAPI:SetSize(newWidth, newHeight)
        		windowWidth = newWidth
        		originalHeight = newHeight
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        	end

        	function windowAPI:SetPosition(x, y)
        		frame.Position = UDim2.new(0, x, 0, y)
        	end

        	function windowAPI:Center()
        		local viewportSize = Window:GetViewportSize()
        		local size = frame.AbsoluteSize
        		frame.Position = UDim2.new(
        			0, (viewportSize.X - size.X) / 2,
        			0, (viewportSize.Y - size.Y) / 2
        		)
        	end

        	function windowAPI:SetResizable(enabled)
        		if resizeHandle then
        			resizeHandle.Visible = enabled
        		end
        	end

        	function windowAPI:GetSize()
        		return frame.AbsoluteSize
        	end

        	function windowAPI:SetTabPanelWidth(newWidth)
        		newWidth = math.max(minTabPanelWidth, math.min(maxTabPanelWidth, newWidth))
        		tabPanel.Size = UDim2.new(0, newWidth, 1, -30)
        		scrollFrame.Position = UDim2.new(0, newWidth, 0, 30)
        		scrollFrame.Size = UDim2.new(1, -newWidth, 1, -30)
        	end

        	function windowAPI:GetTabPanelWidth()
        		return tabPanel.AbsoluteSize.X
        	end

        	function windowAPI:SetTabPanelResizable(enabled)
        		if tabPanelResizer then
        			tabPanelResizer.Visible = enabled
        		end
        	end

        	function windowAPI:GetTabs()
        		return tabs
        	end

        	function windowAPI:GetCurrentTab()
        		return currentTab
        	end

        	function windowAPI:SelectTab(index)
        		if tabs[index] then
        			if currentTab then
        				currentTab:Deselect()
        			end
        			currentTab = tabs[index]
        			currentTab:Select()
        		end
        	end

        	function windowAPI:AddTab(config)
        		-- Handle string shortcut
        		if type(config) == "string" then
        			config = {Name = config}
        		end

        		-- Validate config
        		if type(config) ~= "table" then
        			return nil
        		end

        		local tabName = config.Name or "Tab " .. (tabCount + 1)
        		local icon = config.Icon or ""

        		-- Create the tab using Tab component
        		local tabConfig = {
        			Name = tabName,
        			Icon = icon,
        			TabScrollFrame = tabScrollFrame,
        			TabContents = tabContents,
        			ScrollFrame = scrollFrame,
        			ScreenGui = screenGui,
        			WindowAPI = windowAPI,  -- Pass window API reference for accordion canvas updates
        			UpdateCanvasSize = updateCanvasSize,  -- Pass canvas update function
        			Settings = settings  -- Optional settings for the tab
        		}

        		local tabAPI = Tab:Create(tabConfig)

        		if not tabAPI then
        			return nil
        		end

        		-- Add click handler to switch tabs
        		tabAPI.Button.MouseButton1Click:Connect(function()
        			if currentTab and currentTab ~= tabAPI then
        				currentTab:Deselect()
        			end
        			currentTab = tabAPI
        			tabAPI:Select()
        		end)

        		-- Store tab reference
        		tabCount = tabCount + 1
        		tabs[tabCount] = tabAPI

        		-- Auto-select first tab
        		if tabCount == 1 then
        			currentTab = tabAPI
        			tabAPI:Select()
        		end

        		-- Update tab scroll canvas size
        		tabScrollFrame.CanvasSize = UDim2.new(0, 0, 0, tabListLayout.AbsoluteContentSize.Y)

        		return tabAPI
        	end

        	-- Notification methods
        	function windowAPI:ShowNotification(config)
        		if not Notification then
        			return nil
        		end
        		config = config or {}
        		config.ScreenGui = screenGui
        		return Notification:Create(config)
        	end

        	function windowAPI:ShowSuccess(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "success",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowWarning(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "warning",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowError(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "error",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:ShowInfo(title, message, duration, action)
        		return self:ShowNotification({
        			Type = "info",
        			Title = title,
        			Message = message,
        			Duration = duration,
        			Action = action
        		})
        	end

        	function windowAPI:DismissNotification(id)
        		if Notification then
        			Notification:Dismiss(id)
        		end
        	end

        	function windowAPI:ClearNotifications()
        		if Notification then
        			Notification:Clear()
        		end
        	end

        	function windowAPI:GetConfigValue(key)
        		return settings:GetValue(key)
        	end

        	function windowAPI:SetConfigValue(key, value)
        		settings:SetValue(key, value)
        	end

        	-- Viewport adaptation methods
        	function windowAPI:AdaptToViewport()
        		-- Recalculate window size based on current viewport
        		local currentViewport = self:GetViewportSize()
        		local baseWidth = config.Width or (currentViewport.X * 0.3)
        		local baseHeight = config.Height or (currentViewport.Y * 0.4)

        		-- Apply resolution-based scaling
        		local scaleMultiplier = 1
        		if currentViewport.X >= 1920 then -- 1080p+
        			scaleMultiplier = 1.2
        		elseif currentViewport.X >= 1366 then -- 720p-1080p
        			scaleMultiplier = 1.0
        		elseif currentViewport.X >= 1024 then -- Tablet size
        			scaleMultiplier = 0.9
        		else -- Mobile/small screens
        			scaleMultiplier = 0.8
        		end

        		-- Calculate new size with limits
        		local newWidth = math.max(250, math.min(currentViewport.X * 0.8, baseWidth * scaleMultiplier))
        		local newHeight = math.max(150, math.min(currentViewport.Y * 0.8, baseHeight * scaleMultiplier))

        		-- Apply new size and center the window
        		frame.Size = UDim2.new(0, newWidth, 0, newHeight)
        		frame.Position = UDim2.new(0.5, -newWidth / 2, 0.5, -newHeight / 2)
        	end

        	function windowAPI:GetDynamicSize()
        		local currentViewport = self:GetViewportSize()
        		return {
        			Width = frame.Size.X.Offset,
        			Height = frame.Size.Y.Offset,
        			ViewportWidth = currentViewport.X,
        			ViewportHeight = currentViewport.Y
        		}
        	end

        	function windowAPI:SetSize(width, height)
        		local viewportSize = self:GetViewportSize()

        		-- Apply constraints
        		width = math.max(300, math.min(width, viewportSize.X * 0.9))
        		height = math.max(200, math.min(height, viewportSize.Y * 0.9))

        		frame.Size = UDim2.new(0, width, 0, height)

        		return {Width = width, Height = height}
        	end

        	-- Close callback functionality
        	function windowAPI:SetCloseCallback(callback)
        		onCloseCallback = callback
        	end

        	function windowAPI:Close()
        		-- Call user callback before destroying
        		if onCloseCallback then
        			local success, errorMsg = pcall(function()
        				onCloseCallback()
        			end)

        			if not success then
        			end
        		end

        		-- Destroy the UI
        		if screenGui then
        			screenGui:Destroy()
        		end
        	end

        	-- Auto-adapt to viewport changes (optional)
        	if autoAdapt then
        		workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        			task.wait(0.1) -- Small delay to ensure viewport is stable
        			windowAPI:AdaptToViewport()
        		end)
        	end

        	return windowAPI
        end

        return Window

    end

    -- Module: utils/colors
    EmbeddedModules["utils/colors"] = function()
        --[[
        	EzUI Color Palette Module
        	Dark Mode Color Scheme for Roblox GUI

        	Author: EzUI Library
        	Version: 1.0.0

        	Usage:
        		local m = require(path.to.color)
        		myFrame.BackgroundColor3 = Colors.Background.Primary
        		myButton.BackgroundColor3 = Colors.Button.Default
        ]]

        local Colors = {}

        -- ============================================
        -- BACKGROUND COLORS
        -- ============================================
        Colors.Background = {
        	Primary = Color3.fromRGB(30, 30, 35),      -- Main background
        	Secondary = Color3.fromRGB(40, 40, 45),    -- Secondary panels
        	Tertiary = Color3.fromRGB(50, 50, 55),     -- Elevated elements
        	Overlay = Color3.fromRGB(20, 20, 25),      -- Modal overlays
        	Transparent = Color3.fromRGB(0, 0, 0),     -- For transparent elements
        }

        -- ============================================
        -- SURFACE COLORS (Components)
        -- ============================================
        Colors.Surface = {
        	Default = Color3.fromRGB(45, 45, 50),      -- Default surface
        	Elevated = Color3.fromRGB(55, 55, 60),     -- Elevated surface
        	Hover = Color3.fromRGB(60, 60, 65),        -- Hover state
        	Active = Color3.fromRGB(65, 65, 70),       -- Active/Pressed state
        	Disabled = Color3.fromRGB(35, 35, 40),     -- Disabled state
        }

        -- ============================================
        -- TEXT COLORS
        -- ============================================
        Colors.Text = {
        	Primary = Color3.fromRGB(255, 255, 255),   -- Primary text (high contrast)
        	Secondary = Color3.fromRGB(200, 200, 205), -- Secondary text (medium contrast)
        	Tertiary = Color3.fromRGB(150, 150, 155),  -- Tertiary text (low contrast)
        	Disabled = Color3.fromRGB(100, 100, 105),  -- Disabled text
        	Placeholder = Color3.fromRGB(120, 120, 125), -- Placeholder text
        	Link = Color3.fromRGB(100, 150, 255),      -- Link text
        	LinkHover = Color3.fromRGB(120, 170, 255), -- Link hover
        }

        -- ============================================
        -- BORDER COLORS
        -- ============================================
        Colors.Border = {
        	Default = Color3.fromRGB(80, 80, 85),      -- Default border
        	Light = Color3.fromRGB(100, 100, 105),     -- Light border
        	Dark = Color3.fromRGB(60, 60, 65),         -- Dark border
        	Focus = Color3.fromRGB(100, 150, 255),     -- Focused border
        	Error = Color3.fromRGB(255, 100, 100),     -- Error border
        	Success = Color3.fromRGB(100, 255, 150),   -- Success border
        }

        -- ============================================
        -- BUTTON COLORS
        -- ============================================
        Colors.Button = {
        	-- Primary Button
        	Primary = Color3.fromRGB(100, 150, 255),
        	PrimaryHover = Color3.fromRGB(120, 170, 255),
        	PrimaryActive = Color3.fromRGB(80, 130, 235),
        	PrimaryDisabled = Color3.fromRGB(60, 90, 150),

        	-- Secondary Button
        	Secondary = Color3.fromRGB(80, 80, 90),
        	SecondaryHover = Color3.fromRGB(100, 100, 110),
        	SecondaryActive = Color3.fromRGB(70, 70, 80),
        	SecondaryDisabled = Color3.fromRGB(50, 50, 60),

        	-- Success Button
        	Success = Color3.fromRGB(76, 175, 80),
        	SuccessHover = Color3.fromRGB(96, 195, 100),
        	SuccessActive = Color3.fromRGB(56, 155, 60),
        	SuccessDisabled = Color3.fromRGB(46, 115, 50),

        	-- Danger Button
        	Danger = Color3.fromRGB(244, 67, 54),
        	DangerHover = Color3.fromRGB(255, 87, 74),
        	DangerActive = Color3.fromRGB(224, 47, 34),
        	DangerDisabled = Color3.fromRGB(150, 40, 35),

        	-- Warning Button
        	Warning = Color3.fromRGB(255, 193, 7),
        	WarningHover = Color3.fromRGB(255, 213, 27),
        	WarningActive = Color3.fromRGB(235, 173, 0),
        	WarningDisabled = Color3.fromRGB(150, 120, 10),
        }

        -- ============================================
        -- INPUT COLORS (TextBox, SelectBox, etc)
        -- ============================================
        Colors.Input = {
        	Background = Color3.fromRGB(60, 60, 65),
        	BackgroundHover = Color3.fromRGB(70, 70, 75),
        	BackgroundFocus = Color3.fromRGB(65, 65, 70),
        	BackgroundDisabled = Color3.fromRGB(45, 45, 50),
        	Border = Color3.fromRGB(100, 100, 105),
        	BorderFocus = Color3.fromRGB(100, 150, 255),
        	BorderError = Color3.fromRGB(255, 100, 100),
        	Text = Color3.fromRGB(255, 255, 255),
        	Placeholder = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- TOGGLE/SWITCH COLORS
        -- ============================================
        Colors.Toggle = {
        	On = Color3.fromRGB(76, 175, 80),
        	Off = Color3.fromRGB(100, 100, 100),
        	Handle = Color3.fromRGB(255, 255, 255),
        	Disabled = Color3.fromRGB(70, 70, 75),
        }

        -- ============================================
        -- SLIDER COLORS
        -- ============================================
        Colors.Slider = {
        	Track = Color3.fromRGB(80, 80, 85),
        	TrackFilled = Color3.fromRGB(100, 150, 255),
        	Handle = Color3.fromRGB(255, 255, 255),
        	HandleHover = Color3.fromRGB(245, 245, 245),
        	HandleActive = Color3.fromRGB(230, 230, 230),
        	HandleDisabled = Color3.fromRGB(150, 150, 155),
        }

        -- ============================================
        -- DROPDOWN COLORS
        -- ============================================
        Colors.Dropdown = {
        	Background = Color3.fromRGB(45, 45, 50),
        	Option = Color3.fromRGB(50, 50, 55),
        	OptionHover = Color3.fromRGB(70, 70, 75),
        	OptionSelected = Color3.fromRGB(70, 120, 70),
        	OptionActive = Color3.fromRGB(100, 150, 255),
        	Border = Color3.fromRGB(150, 150, 155),
        	Arrow = Color3.fromRGB(200, 200, 205),
        }

        -- ============================================
        -- SCROLLBAR COLORS
        -- ============================================
        Colors.Scrollbar = {
        	Background = Color3.fromRGB(40, 40, 45),
        	Thumb = Color3.fromRGB(120, 120, 125),
        	ThumbHover = Color3.fromRGB(140, 140, 145),
        	ThumbActive = Color3.fromRGB(160, 160, 165),
        }

        -- ============================================
        -- STATUS COLORS (Semantic m)
        -- ============================================
        Colors.Status = {
        	Success = Color3.fromRGB(76, 175, 80),
        	Warning = Color3.fromRGB(255, 193, 7),
        	Error = Color3.fromRGB(244, 67, 54),
        	Info = Color3.fromRGB(33, 150, 243),
        }

        -- ============================================
        -- ACCENT COLORS
        -- ============================================
        Colors.Accent = {
        	Primary = Color3.fromRGB(100, 150, 255),   -- Blue
        	Secondary = Color3.fromRGB(156, 39, 176),  -- Purple
        	Success = Color3.fromRGB(76, 175, 80),     -- Green
        	Warning = Color3.fromRGB(255, 193, 7),     -- Yellow
        	Danger = Color3.fromRGB(244, 67, 54),      -- Red
        	Info = Color3.fromRGB(33, 150, 243),       -- Light Blue
        }

        -- ============================================
        -- SPECIAL COLORS
        -- ============================================
        Colors.Special = {
        	Shadow = Color3.fromRGB(0, 0, 0),          -- For shadows
        	Highlight = Color3.fromRGB(255, 255, 255), -- For highlights
        	Overlay = Color3.fromRGB(0, 0, 0),         -- For modal overlays (use with transparency)
        	Divider = Color3.fromRGB(80, 80, 85),      -- For separators/dividers
        }

        -- ============================================
        -- TAB COLORS
        -- ============================================
        Colors.Tab = {
        	Background = Color3.fromRGB(50, 50, 50),
        	BackgroundHover = Color3.fromRGB(60, 60, 60),
        	BackgroundActive = Color3.fromRGB(70, 70, 75),
        	Text = Color3.fromRGB(255, 255, 255),
        	TextInactive = Color3.fromRGB(180, 180, 185),
        	Indicator = Color3.fromRGB(100, 150, 255),
        }

        -- ============================================
        -- NOTIFICATION COLORS
        -- ============================================
        Colors.Notification = {
        	Success = {
        		Background = Color3.fromRGB(46, 125, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(76, 175, 80),
        	},
        	Warning = {
        		Background = Color3.fromRGB(245, 127, 23),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(255, 193, 7),
        	},
        	Error = {
        		Background = Color3.fromRGB(211, 47, 47),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(244, 67, 54),
        	},
        	Info = {
        		Background = Color3.fromRGB(25, 118, 210),
        		Text = Color3.fromRGB(255, 255, 255),
        		Border = Color3.fromRGB(33, 150, 243),
        	},
        }

        -- ============================================
        -- UTILITY FUNCTIONS
        -- ============================================

        -- Convert Color3 to hex string
        function Colors:ToHex(color3)
        	local r = math.floor(color3.R * 255)
        	local g = math.floor(color3.G * 255)
        	local b = math.floor(color3.B * 255)
        	return string.format("#%02X%02X%02X", r, g, b)
        end

        -- Convert hex string to Color3
        function Colors:FromHex(hex)
        	hex = hex:gsub("#", "")
        	local r = tonumber("0x" .. hex:sub(1, 2)) / 255
        	local g = tonumber("0x" .. hex:sub(3, 4)) / 255
        	local b = tonumber("0x" .. hex:sub(5, 6)) / 255
        	return Color3.new(r, g, b)
        end

        -- Lighten a color by a percentage (0-1)
        function Colors:Lighten(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Darken a color by a percentage (0-1)
        function Colors:Darken(color3, amount)
        	amount = math.clamp(amount, 0, 1)
        	local h, s, v = color3:ToHSV()
        	v = math.clamp(v - amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Adjust saturation of a color
        function Colors:Saturate(color3, amount)
        	amount = math.clamp(amount, -1, 1)
        	local h, s, v = color3:ToHSV()
        	s = math.clamp(s + amount, 0, 1)
        	return Color3.fromHSV(h, s, v)
        end

        -- Mix two colors with a ratio (0 = color1, 1 = color2)
        function Colors:Mix(color1, color2, ratio)
        	ratio = math.clamp(ratio, 0, 1)
        	return Color3.new(
        		color1.R + (color2.R - color1.R) * ratio,
        		color1.G + (color2.G - color1.G) * ratio,
        		color1.B + (color2.B - color1.B) * ratio
        	)
        end

        -- Get contrasting text color (black or white) based on background
        function Colors:GetContrastText(backgroundColor)
        	local luminance = (0.299 * backgroundColor.R + 0.587 * backgroundColor.G + 0.114 * backgroundColor.B)
        	return luminance > 0.5 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
        end

        -- Apply alpha/transparency to a color (returns color and transparency value)
        function Colors:WithAlpha(color3, alpha)
        	alpha = math.clamp(alpha, 0, 1)
        	return color3, 1 - alpha
        end

        -- Create a gradient of colors
        function Colors:CreateGradient(startColor, endColor, steps)
        	local gradient = {}
        	for i = 0, steps - 1 do
        		local ratio = i / (steps - 1)
        		table.insert(gradient, Colors.Mix(startColor, endColor, ratio))
        	end
        	return gradient
        end

        -- ============================================
        -- PRESET THEMES
        -- ============================================
        Colors.Themes = {
        	-- Default Dark Theme (already defined above)
        	Dark = {
        		Name = "Dark",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(30, 30, 35),
        		Surface = Color3.fromRGB(45, 45, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Darker Theme
        	Darker = {
        		Name = "Darker",
        		Primary = Color3.fromRGB(100, 150, 255),
        		Background = Color3.fromRGB(15, 15, 20),
        		Surface = Color3.fromRGB(25, 25, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Blue Dark Theme
        	BlueDark = {
        		Name = "Blue Dark",
        		Primary = Color3.fromRGB(33, 150, 243),
        		Background = Color3.fromRGB(18, 32, 47),
        		Surface = Color3.fromRGB(28, 42, 57),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Purple Dark Theme
        	PurpleDark = {
        		Name = "Purple Dark",
        		Primary = Color3.fromRGB(156, 39, 176),
        		Background = Color3.fromRGB(30, 20, 35),
        		Surface = Color3.fromRGB(45, 30, 50),
        		Text = Color3.fromRGB(255, 255, 255),
        	},

        	-- Green Dark Theme
        	GreenDark = {
        		Name = "Green Dark",
        		Primary = Color3.fromRGB(76, 175, 80),
        		Background = Color3.fromRGB(20, 30, 20),
        		Surface = Color3.fromRGB(30, 45, 30),
        		Text = Color3.fromRGB(255, 255, 255),
        	},
        }

        -- ============================================
        -- RETURN MODULE
        -- ============================================
        return Colors

    end

    -- Module: utils/config
    EmbeddedModules["utils/config"] = function()
        local Config = {}
        local HttpService = game:GetService("HttpService")

        function Config:NewConfig(config)
        	-- Support both old style (string, string) and new style (table)
        	local configName, directory

        	if type(config) == "table" then
        		-- New style: table parameter
        		configName = config.ConfigName or config.FileName or config.Name
        		directory = config.Directory or config.FolderName
        	elseif type(config) == "string" then
        		-- Old style: first parameter is configName
        		configName = config
        		directory = nil
        	else
        		return nil
        	end

        	if not configName or type(configName) ~= "string" then
        		return nil
        	end

        	-- Use custom directory or default to EzUI Configuration folder
        	local customDirectory = directory
        	if customDirectory and type(customDirectory) ~= "string" then
        		customDirectory = nil
        	end

        	-- Create independent storage for this custom config
        	local Flags = {}

        	-- Save function for this custom config
        	local function SaveConfiguration()

        		-- Filter out keys with nil values
        		local dataToSave = {}
        		local hasData = false

        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				dataToSave[key] = value
        				hasData = true
        			end
        		end

        		if not hasData then
        			return false
        		end

        		if not writefile or not isfolder or not makefolder then
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local dynamicFolderName, dynamicConfigurationFolder, filePath

        		if customDirectory then
        			-- Custom directory path
        			dynamicFolderName = customDirectory
        			dynamicConfigurationFolder = customDirectory
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		-- Create folders if they don't exist
        		if not isfolder(dynamicFolderName) then
        			makefolder(dynamicFolderName)
        		end

        		-- Only create Configurations subfolder if not using custom directory
        		if not customDirectory and not isfolder(dynamicConfigurationFolder) then
        			makefolder(dynamicConfigurationFolder)
        		end

        		-- Save to JSON file
        		local success, result = pcall(function()
        			writefile(filePath, HttpService:JSONEncode(dataToSave))
        		end)

        		if success then
        			local savedCount = 0
        			for _ in pairs(dataToSave) do
        				savedCount = savedCount + 1
        			end
        			return true
        		else
        			return false
        		end
        	end

        	-- Load function for this custom config
        	local function LoadConfiguration()
        		if not readfile or not isfile then
        			return false
        		end

        		-- Use custom directory or default to EzUI folder structure
        		local filePath

        		if customDirectory then
        			-- Custom directory path
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			-- Default EzUI folder structure
        			local dynamicFolderName = EzUI.Configuration.FolderName or "EzUI"
        			local dynamicConfigurationFolder = dynamicFolderName .. "/Configurations"
        			filePath = dynamicConfigurationFolder .. "/" .. configName .. ".json"
        		end

        		if not isfile(filePath) then
        			return false
        		end

        		local success, configData = pcall(function()
        			-- Decode JSON data
        			return HttpService:JSONDecode(readfile(filePath))
        		end)

        		if not success then
        			return false
        		end

        		-- Apply loaded data and update components
        		local applied = 0
        		for flagName, flagValue in pairs(configData) do
        			Flags[flagName] = flagValue
        			applied = applied + 1
        		end

        		return true
        	end

        	local configAPI = {}

        	-- Get value by key
        	function configAPI:GetValue(key)
        		if not key then
        			return nil
        		end
        		return Flags[key]
        	end

        	-- Set value by key and update associated components
        	function configAPI:SetValue(key, value)
        		if not key then
        			return false
        		end


        		Flags[key] = value

        		SaveConfiguration()
        		return true
        	end

        	-- Get all key-value pairs
        	function configAPI:GetAll()
        		local result = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				result[key] = value
        			end
        		end
        		return result
        	end

        	-- Get All Keys
        	function configAPI:GetAllKeys()
        		local keys = {}
        		for key, value in pairs(Flags) do
        			if value ~= nil then
        				table.insert(keys, key)
        			end
        		end
        		return keys
        	end

        	-- Delete a specific key
        	function configAPI:DeleteKey(key)
        		if not key then
        			return false
        		end

        		if Flags[key] ~= nil then
        			Flags[key] = nil

        			SaveConfiguration()
        			return true
        		else
        			return false
        		end
        	end

        	-- Get configuration info
        	function configAPI:GetInfo()
        		local folderName, configFolder, filePath

        		if customDirectory then
        			folderName = customDirectory
        			configFolder = customDirectory
        			filePath = customDirectory .. "/" .. configName .. ".json"
        		else
        			folderName = EzUI.Configuration.FolderName or "EzUI"
        			configFolder = folderName .. "/Configurations"
        			filePath = configFolder .. "/" .. configName .. ".json"
        		end

        		return {
        			ConfigName = configName,
        			CustomDirectory = customDirectory,
        			FolderName = folderName,
        			ConfigFolder = configFolder,
        			FilePath = filePath,
        			IsCustomDirectory = customDirectory ~= nil
        		}
        	end

        	-- Manual save
        	function configAPI:Save()
        		return SaveConfiguration()
        	end

        	-- Manual load
        	function configAPI:Load()
        		return LoadConfiguration()
        	end

        	-- Return custom configuration object
        	return configAPI
        end

        return Config
    end

    -- Module: components/accordion
    EmbeddedModules["components/accordion"] = function()
        --[[
        	Accordion Component
        	EzUI Library - Modular Component

        	Creates a collapsible accordion with dynamic content
        	Uses proven logic from old ui.lua for reliable expand/collapse behavior
        ]]

        -- Component modules (will be loaded by Window)
        local Accordion = {}

        local Colors
        local Button
        local Toggle
        local TextBox
        local NumberBox
        local SelectBox
        local Label
        local Separator

        -- Initialize component modules
        function Accordion:Init(_colors, _button, _toggle, _textbox, _numberbox, _selectbox, _label, _separator)
        	Colors = _colors
        	Button = _button
        	Toggle = _toggle
        	TextBox = _textbox
        	NumberBox = _numberbox
        	SelectBox = _selectbox
        	Label = _label
        	Separator = _separator
        end

        function Accordion:Create(config)
        	-- Configuration
        	local title = config.Title or config.Name or "Accordion"
        	local expanded = config.Expanded or config.Open or config.DefaultExpanded or false
        	local icon = config.Icon or ""
        	local tabContent = config.Parent
        	local accordionStartY = config.Y or 0

        	-- Accordion state
        	local isExpanded = expanded
        	local callback = config.Callback -- function dipanggil saat expand/collapse/toggle
        	local accordionContentHeight = 0

        	-- Main accordion container
        	local accordionContainer = Instance.new("Frame")
        	accordionContainer.Size = UDim2.new(1, -20, 0, 30) -- Initial height just for header
        	accordionContainer.Position = UDim2.new(0, 10, 0, accordionStartY)
        	accordionContainer.BackgroundTransparency = 1
        	accordionContainer.ClipsDescendants = false -- Allow content to show
        	accordionContainer.ZIndex = 3
        	accordionContainer.Parent = tabContent

        	-- Store reference to this accordion
        	accordionContainer:SetAttribute("AccordionStartY", accordionStartY)
        	accordionContainer:SetAttribute("IsAccordion", true)

        	-- Accordion header (clickable)
        	local accordionHeader = Instance.new("TextButton")
        	accordionHeader.Size = UDim2.new(1, 0, 0, 30)
        	accordionHeader.Position = UDim2.new(0, 0, 0, 0)
        	accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	accordionHeader.BorderSizePixel = 0
        	accordionHeader.Text = ""
        	accordionHeader.ZIndex = 4
        	accordionHeader.Parent = accordionContainer

        	-- Header round corners
        	local headerCorner = Instance.new("UICorner")
        	headerCorner.CornerRadius = UDim.new(0, 4)
        	headerCorner.Parent = accordionHeader

        	-- Expand/Collapse arrow
        	local accordionArrow = Instance.new("TextLabel")
        	accordionArrow.Size = UDim2.new(0, 30, 1, 0)
        	accordionArrow.Position = UDim2.new(0, 5, 0, 0)
        	accordionArrow.BackgroundTransparency = 1
        	accordionArrow.Text = isExpanded and "▼" or "►"
        	accordionArrow.TextColor3 = Colors.Text.Secondary
        	accordionArrow.TextSize = 12
        	accordionArrow.Font = Enum.Font.SourceSansBold
        	accordionArrow.ZIndex = 5
        	accordionArrow.Parent = accordionHeader

        	-- Icon (optional)
        	local accordionIcon = Instance.new("TextLabel")
        	accordionIcon.Size = UDim2.new(0, 25, 1, 0)
        	accordionIcon.Position = UDim2.new(0, 30, 0, 0)
        	accordionIcon.BackgroundTransparency = 1
        	accordionIcon.Text = icon
        	accordionIcon.TextColor3 = Colors.Text.Primary
        	accordionIcon.TextXAlignment = Enum.TextXAlignment.Center
        	accordionIcon.Font = Enum.Font.SourceSans
        	accordionIcon.TextSize = 14
        	accordionIcon.ZIndex = 5
        	accordionIcon.Parent = accordionHeader

        	-- Accordion title
        	local accordionTitle = Instance.new("TextLabel")
        	accordionTitle.Size = UDim2.new(1, -70, 1, 0)
        	accordionTitle.Position = UDim2.new(0, 60, 0, 0)
        	accordionTitle.BackgroundTransparency = 1
        	accordionTitle.Text = title
        	accordionTitle.TextColor3 = Colors.Text.Primary
        	accordionTitle.TextXAlignment = Enum.TextXAlignment.Left
        	accordionTitle.Font = Enum.Font.SourceSansBold
        	accordionTitle.TextSize = 14
        	accordionTitle.ZIndex = 5
        	accordionTitle.Parent = accordionHeader

        	-- Accordion content container (no scroll)
        	local accordionContent = Instance.new("Frame")
        	accordionContent.Size = UDim2.new(1, 0, 0, 0) -- Start with 0 height
        	accordionContent.Position = UDim2.new(0, 0, 0, 32) -- Below header
        	accordionContent.BackgroundColor3 = Colors.Background.Tertiary
        	accordionContent.BorderSizePixel = 0
        	accordionContent.Visible = isExpanded
        	accordionContent.ClipsDescendants = false -- Don't clip content
        	accordionContent.ZIndex = 4
        	accordionContent.Parent = accordionContainer

        	-- Round corners for content
        	local contentCorner = Instance.new("UICorner")
        	contentCorner.CornerRadius = UDim.new(0, 4)
        	contentCorner.Parent = accordionContent

        	-- Add padding to accordion content
        	local contentPadding = Instance.new("UIPadding")
        	contentPadding.PaddingTop = UDim.new(0, 5)
        	contentPadding.PaddingBottom = UDim.new(0, 5)
        	contentPadding.PaddingLeft = UDim.new(0, 5)
        	contentPadding.PaddingRight = UDim.new(0, 5)
        	contentPadding.Parent = accordionContent

        	-- Content layout
        	local contentLayout = Instance.new("UIListLayout")
        	contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
        	contentLayout.Padding = UDim.new(0, 5)
        	contentLayout.Parent = accordionContent

        	-- Track layout order for accordion content (UIListLayout handles actual positioning)
        	local accordionCurrentY = 1

        	-- Function to update positions of all components below this accordion (FROM UI.LUA)
        	local function updateComponentsBelow()
        		-- Get current accordion bottom position
        		local accordionBottom = accordionContainer.Position.Y.Offset + accordionContainer.Size.Y.Offset

        		-- Create a list of all components with their Y positions
        		local components = {}
        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				-- Check if this component has a stored start Y position
        				local componentStartY = child:GetAttribute("ComponentStartY")
        				if componentStartY and componentStartY > accordionStartY then
        					table.insert(components, {
        						component = child,
        						originalY = componentStartY,
        						currentY = child.Position.Y.Offset
        					})
        				end
        			end
        		end

        		-- Sort components by their original Y position
        		table.sort(components, function(a, b)
        			return a.originalY < b.originalY
        		end)

        		-- Update positions of components that come after this accordion
        		local nextY = accordionBottom + 5
        		for _, componentData in ipairs(components) do
        			componentData.component.Position = UDim2.new(0, 10, 0, nextY)
        			-- Add the component's height to calculate next position
        			nextY = nextY + componentData.component.Size.Y.Offset + 5
        		end
        	end

        	-- Function to recalculate total tab height (FROM UI.LUA)
        	local function recalculateTabHeight()
        		-- Wait to ensure all size updates are rendered
        		task.wait()

        		-- Callback to parent tab to recalculate
        		if config.OnHeightChanged then
        			config.OnHeightChanged()
        		end
        	end

        	-- Function to update accordion container size (FROM UI.LUA)
        	local function updateAccordionSize()
        		-- Get the actual content size from UIListLayout
        		local actualContentHeight = contentLayout.AbsoluteContentSize.Y + 20 -- Add padding
        		accordionContentHeight = actualContentHeight

        		-- Update accordion container size
        		local totalHeight = 35 + (isExpanded and accordionContentHeight or 0)
        		accordionContainer.Size = UDim2.new(1, -20, 0, totalHeight)

        		-- Update accordion content frame size
        		if isExpanded then
        			accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		end

        		-- Update positions of components below
        		updateComponentsBelow()

        		-- Recalculate total tab height
        		recalculateTabHeight()
        	end

        	-- Auto-update accordion size when content layout changes (now that updateAccordionSize is defined)
        	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        		-- Always update the content height, regardless of expanded state
        		updateAccordionSize()
        	end)

        	-- Animation function for smooth expand/collapse (FROM UI.LUA)
        	local function animateAccordion()
        		local TweenService = game:GetService("TweenService")

        		-- Calculate sizes BEFORE any changes
        		local oldContainerHeight = accordionContainer.Size.Y.Offset
        		local targetContentHeight = isExpanded and accordionContentHeight or 0
        		local targetContainerHeight = 35 + targetContentHeight
        		local heightDifference = targetContainerHeight - oldContainerHeight

        		-- Store components that come after this accordion BEFORE size changes
        		local componentsBelow = {}
        		local accordionBottom = accordionContainer.Position.Y.Offset + oldContainerHeight

        		for _, child in pairs(tabContent:GetChildren()) do
        			if child:IsA("GuiObject") and child ~= accordionContainer then
        				local childY = child.Position.Y.Offset
        				if childY > accordionBottom then
        					table.insert(componentsBelow, {
        						component = child,
        						currentY = childY,
        						targetY = childY + heightDifference
        					})
        				end
        			end
        		end

        		-- Update arrow direction
        		accordionArrow.Text = isExpanded and "▼" or "►"

        		-- Show content immediately if expanding
        		if isExpanded then
        			accordionContent.Visible = true
        		end

        		-- Animate container size
        		local containerTween = TweenService:Create(
        			accordionContainer,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, -20, 0, targetContainerHeight)}
        		)

        		-- Animate content size
        		local contentTween = TweenService:Create(
        			accordionContent,
        			TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        			{Size = UDim2.new(1, 0, 0, targetContentHeight)}
        		)

        		-- Animate components below
        		for _, componentData in ipairs(componentsBelow) do
        			local componentTween = TweenService:Create(
        				componentData.component,
        				TweenInfo.new(0.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out),
        				{Position = UDim2.new(0, 10, 0, componentData.targetY)}
        			)
        			componentTween:Play()
        		end

        		containerTween:Play()
        		contentTween:Play()

        		-- Handle animation completion
        		containerTween.Completed:Connect(function()
        			-- Hide content after collapse animation
        			if not isExpanded then
        				accordionContent.Visible = false
        			end

        			-- Wait for next frame to ensure sizes are updated
        			task.wait()

        			-- Recalculate total tab height
        			recalculateTabHeight()
        		end)
        	end

        	-- Header click handler
        	accordionHeader.MouseButton1Click:Connect(function()
        		isExpanded = not isExpanded
        		animateAccordion()
        	end)

        	-- Header hover effects
        	accordionHeader.MouseEnter:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Hover
        	end)

        	accordionHeader.MouseLeave:Connect(function()
        		accordionHeader.BackgroundColor3 = Colors.Surface.Default
        	end)

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Create accordion API
        	local accordionAPI = {
        		Container = accordionContainer,
        		ContentFrame = accordionContent,
        	}

        	-- Accordion control methods
        	function accordionAPI:Expand()
        		if not isExpanded then
        			isExpanded = true
        			animateAccordion()
        			if callback then callback(true) end -- true = dibuka
        		end
        	end

        	function accordionAPI:Collapse()
        		if isExpanded then
        			isExpanded = false
        			animateAccordion()
        			if callback then callback(false) end -- false = ditutup
        		end
        	end

        	function accordionAPI:Toggle()
        	isExpanded = not isExpanded
        	animateAccordion()
        	if callback then callback(isExpanded) end -- true/false
        	return isExpanded
        	end

        	function accordionAPI:IsExpanded()
        		return isExpanded
        	end

        	function accordionAPI:SetTitle(newTitle)
        		title = newTitle
        		accordionTitle.Text = newTitle
        	end

        	function accordionAPI:SetIcon(newIcon)
        		icon = newIcon
        		accordionIcon.Text = newIcon
        	end

        	function accordionAPI:GetHeight()
        		return accordionContainer.AbsoluteSize.Y
        	end

        	function accordionAPI:GetContentHeight()
        		return accordionContentHeight
        	end

        	-- Add Label method
        	function accordionAPI:AddLabel(labelConfig)
        		if not Label then return nil end

        		local lblConfig
        		if type(labelConfig) == "string" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "function" then
        			lblConfig = {Text = labelConfig}
        		elseif type(labelConfig) == "table" then
        			lblConfig = labelConfig
        		else
        			lblConfig = {}
        		end

        		lblConfig.Parent = accordionContent
        		lblConfig.Y = 0
        		lblConfig.IsForAccordion = true
        		-- Size and Color are already passed through if they exist in labelConfig table

        		local labelAPI = Label:Create(lblConfig)
        		if labelAPI and labelAPI.Label then
        			-- UIListLayout will handle positioning automatically
        			labelAPI.Label.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- Just increment counter for LayoutOrder
        		end

        		-- Update accordion size (the connection should handle this automatically)
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return labelAPI
        	end

        	-- Add Button method
        	function accordionAPI:AddButton(buttonConfig)
        		if not Button then return nil end

        		local btnConfig
        		if type(buttonConfig) == "string" then
        			btnConfig = {Text = buttonConfig}
        		elseif type(buttonConfig) == "table" then
        			btnConfig = buttonConfig
        		else
        			btnConfig = {}
        		end

        		btnConfig.Parent = accordionContent
        		btnConfig.Y = 0
        		btnConfig.IsForAccordion = true
        		btnConfig.EzUI = config.EzUI
        		btnConfig.SaveConfiguration = config.SaveConfiguration
        		btnConfig.RegisterComponent = config.RegisterComponent

        		local buttonAPI = Button:Create(btnConfig)
        		if buttonAPI and buttonAPI.Button then
        			buttonAPI.Button.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return buttonAPI
        	end

        	-- Add Toggle method
        	function accordionAPI:AddToggle(toggleConfig)
        		if not Toggle then return nil end

        		toggleConfig = toggleConfig or {}
        		toggleConfig.Parent = accordionContent
        		toggleConfig.Y = 0
        		toggleConfig.IsForAccordion = true
        		toggleConfig.EzUI = config.EzUI
        		toggleConfig.SaveConfiguration = config.SaveConfiguration
        		toggleConfig.RegisterComponent = config.RegisterComponent
        		toggleConfig.Settings= config.Settings

        		local toggleAPI = Toggle:Create(toggleConfig)
        		if toggleAPI and toggleAPI.Toggle then
        			toggleAPI.Toggle.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return toggleAPI
        	end

        	-- Add TextBox method
        	function accordionAPI:AddTextBox(textboxConfig)
        		if not TextBox then return nil end

        		textboxConfig = textboxConfig or {}
        		textboxConfig.Parent = accordionContent
        		textboxConfig.Y = 0
        		textboxConfig.IsForAccordion = true
        		textboxConfig.EzUI = config.EzUI
        		textboxConfig.SaveConfiguration = config.SaveConfiguration
        		textboxConfig.RegisterComponent = config.RegisterComponent
        		textboxConfig.Settings= config.Settings

        		local textboxAPI = TextBox:Create(textboxConfig)
        		if textboxAPI and textboxAPI.TextBox then
        			textboxAPI.TextBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return textboxAPI
        	end

        	-- Add NumberBox method
        	function accordionAPI:AddNumberBox(numberboxConfig)
        		if not NumberBox then return nil end

        		numberboxConfig = numberboxConfig or {}
        		numberboxConfig.Parent = accordionContent
        		numberboxConfig.Y = 0
        		numberboxConfig.IsForAccordion = true
        		numberboxConfig.EzUI = config.EzUI
        		numberboxConfig.SaveConfiguration = config.SaveConfiguration
        		numberboxConfig.RegisterComponent = config.RegisterComponent
        		numberboxConfig.Settings= config.Settings

        		local numberboxAPI = NumberBox:Create(numberboxConfig)
        		if numberboxAPI and numberboxAPI.NumberBox then
        			numberboxAPI.NumberBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return numberboxAPI
        	end

        	-- Add SelectBox method
        	function accordionAPI:AddSelectBox(selectboxConfig)
        		if not SelectBox then return nil end

        		selectboxConfig = selectboxConfig or {}
        		selectboxConfig.Parent = accordionContent
        		selectboxConfig.Y = 0
        		selectboxConfig.IsForAccordion = true
        		selectboxConfig.ScreenGui = config.ScreenGui
        		selectboxConfig.EzUI = config.EzUI
        		selectboxConfig.SaveConfiguration = config.SaveConfiguration
        		selectboxConfig.RegisterComponent = config.RegisterComponent
        		selectboxConfig.Settings= config.Settings

        		local selectboxAPI = SelectBox:Create(selectboxConfig)
        		if selectboxAPI and selectboxAPI.SelectBox then
        			selectboxAPI.SelectBox.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return selectboxAPI
        	end

        	-- Add Separator method
        	function accordionAPI:AddSeparator(separatorConfig)
        		if not Separator then return nil end

        		separatorConfig = separatorConfig or {}
        		separatorConfig.Parent = accordionContent
        		separatorConfig.Y = 0
        		separatorConfig.IsForAccordion = true

        		local separatorAPI = Separator:Create(separatorConfig)
        		if separatorAPI and separatorAPI.Separator then
        			separatorAPI.Separator.LayoutOrder = accordionCurrentY
        			accordionCurrentY = accordionCurrentY + 1 -- UIListLayout handles positioning
        		end
        		updateAccordionSize()

        		if isExpanded then
        			animateAccordion()
        		end

        		return separatorAPI
        	end

        	-- Initialize with expanded state
        	if isExpanded then
        		updateAccordionSize()
        		-- Don't animate on initial load, just set the size directly
        		accordionContainer.Size = UDim2.new(1, -20, 0, 35 + accordionContentHeight)
        		accordionContent.Size = UDim2.new(1, 0, 0, accordionContentHeight)
        		accordionContent.Visible = true
        		accordionArrow.Text = "▼"
        	end

        	return accordionAPI
        end

        return Accordion

    end

    -- Module: components/button
    EmbeddedModules["components/button"] = function()
        --[[
        	Button Component
        	EzUI Library - Modular Component

        	Creates a clickable button with hover effects
        ]]
        local Button = {}

        local Colors

        function Button:Init(_colors)
        	Colors = _colors
        end

        function Button:Create(config)
        	local text = config.Text or config.Label or config.Title or config.Name or "Button"
        	local callback = config.Callback or function() end
        	local variant = config.Variant or "primary"
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	-- Function to get variant colors
        	local function getVariantColors(variantName)
        		local variants = {
        			primary = {
        				background = Colors.Button.Primary,
        				backgroundHover = Colors.Button.PrimaryHover,
        				text = Colors.Text.Primary,
        				border = Colors.Text.Primary
        			},
        			secondary = {
        				background = Color3.fromRGB(108, 117, 125),
        				backgroundHover = Color3.fromRGB(90, 98, 104),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(108, 117, 125)
        			},
        			success = {
        				background = Color3.fromRGB(40, 167, 69),
        				backgroundHover = Color3.fromRGB(34, 142, 58),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(40, 167, 69)
        			},
        			warning = {
        				background = Color3.fromRGB(255, 193, 7),
        				backgroundHover = Color3.fromRGB(217, 164, 6),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(255, 193, 7)
        			},
        			danger = {
        				background = Color3.fromRGB(220, 53, 69),
        				backgroundHover = Color3.fromRGB(187, 45, 59),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(220, 53, 69)
        			},
        			info = {
        				background = Color3.fromRGB(13, 202, 240),
        				backgroundHover = Color3.fromRGB(11, 172, 204),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(13, 202, 240)
        			},
        			light = {
        				background = Color3.fromRGB(248, 249, 250),
        				backgroundHover = Color3.fromRGB(211, 212, 213),
        				text = Color3.fromRGB(33, 37, 41),
        				border = Color3.fromRGB(248, 249, 250)
        			},
        			dark = {
        				background = Color3.fromRGB(33, 37, 41),
        				backgroundHover = Color3.fromRGB(28, 31, 35),
        				text = Color3.fromRGB(255, 255, 255),
        				border = Color3.fromRGB(33, 37, 41)
        			}
        		}

        		return variants[variantName] or variants.primary
        	end

        	local variantColors = getVariantColors(variant)

        	local button = Instance.new("TextButton")
        	if isForAccordion then
        		-- Make button width responsive to content (takes full available width)
        		button.Size = UDim2.new(1, -10, 0, 25)
        		-- Don't set Position for accordion buttons - let UIListLayout handle it
        		button.BorderColor3 = variantColors.border
        		button.BorderSizePixel = 2
        		button.TextSize = 12
        		button.ZIndex = 5

        		-- Round corners for accordion button
        		local buttonCorner = Instance.new("UICorner")
        		buttonCorner.CornerRadius = UDim.new(0, 4)
        		buttonCorner.Parent = button

        		-- Button hover effects for accordion
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	else
        		button.Size = UDim2.new(0, 120, 0, 30)
        		button.Position = UDim2.new(0, 10, 0, currentY)
        		button.BorderSizePixel = 0
        		button.TextSize = 14
        		button.ZIndex = 3
        		button:SetAttribute("ComponentStartY", currentY)
        	end
        	button.BackgroundColor3 = variantColors.background
        	button.Text = text
        	button.TextColor3 = variantColors.text
        	button.Font = Enum.Font.SourceSans
        	button.TextScaled = false  -- Keep original text size
        	button.TextWrapped = false -- Don't wrap text to new lines
        	button.TextTruncate = Enum.TextTruncate.AtEnd -- Add ... at end if text is too long
        	button.Parent = parentContainer

        	-- Add hover effects for non-accordion buttons
        	if not isForAccordion then
        		button.MouseEnter:Connect(function()
        			button.BackgroundColor3 = variantColors.backgroundHover
        		end)

        		button.MouseLeave:Connect(function()
        			button.BackgroundColor3 = variantColors.background
        		end)
        	end

        	if callback then
        		button.MouseButton1Click:Connect(callback)
        	end

        	-- Create Button API
        	local buttonAPI = {
        		Button = button
        	}

        	function buttonAPI:SetText(newText)
        		button.Text = newText or ""
        	end

        	function buttonAPI:GetText()
        		return button.Text
        	end

        	function buttonAPI:SetCallback(newCallback)
        		callback = newCallback or function() end
        		button.MouseButton1Click:Connect(callback)
        	end

        	function buttonAPI:SetEnabled(enabled)
        		button.Active = enabled
        		if enabled then
        			button.BackgroundColor3 = variantColors.background
        		else
        			-- Create a disabled version by reducing opacity/brightness
        			local r, g, b = variantColors.background.R, variantColors.background.G, variantColors.background.B
        			button.BackgroundColor3 = Color3.fromRGB(
        				math.floor(r * 255 * 0.5),
        				math.floor(g * 255 * 0.5),
        				math.floor(b * 255 * 0.5)
        			)
        		end
        	end

        	function buttonAPI:SetVariant(newVariant)
        		variant = newVariant or "primary"
        		variantColors = getVariantColors(variant)

        		-- Update button colors
        		button.BackgroundColor3 = variantColors.background
        		button.TextColor3 = variantColors.text
        		if isForAccordion then
        			button.BorderColor3 = variantColors.border
        		end
        	end

        	function buttonAPI:GetVariant()
        		return variant
        	end

        	return buttonAPI
        end

        return Button

    end

    -- Module: components/label
    EmbeddedModules["components/label"] = function()
        --[[
        	Label Component
        	EzUI Library - Modular Component

        	Creates a text label with optional dynamic function support
        ]]
        local Label = {}

        local Colors

        function Label:Init(_colors)
            Colors = _colors
        end

        function Label:Create(config)
        	local text = config.Text or ""
        	local parentContainer = config.Parent
        	local currentY = config.Y or 0
        	local isForAccordion = config.IsForAccordion or false
        	local textSize = config.Size or config.TextSize -- Support both Size and TextSize
        	local textColor = config.Color or config.TextColor -- Support both Color and TextColor

        	-- Handle case where Parent might be a component API object instead of Instance
        	if parentContainer and type(parentContainer) == "table" then
        		-- Look for common GUI object properties in component APIs
        		if parentContainer.Frame then
        			parentContainer = parentContainer.Frame
        		elseif parentContainer.Button then
        			parentContainer = parentContainer.Button
        		elseif parentContainer.Label then
        			parentContainer = parentContainer.Label
        		elseif parentContainer.Container then
        			parentContainer = parentContainer.Container
        		else
        			-- List available keys for debugging
        			local keys = {}
        			for k, v in pairs(parentContainer) do
        				table.insert(keys, tostring(k))
        			end
        			parentContainer = nil
        		end
        	end

        	-- Validate parent is an Instance
        	if parentContainer and not typeof(parentContainer) == "Instance" then
        		parentContainer = nil
        	end

        	local label = Instance.new("TextLabel")
        	if isForAccordion then
        		-- Calculate height based on text size with some padding
        		local calculatedTextSize = textSize or 14
        		local labelHeight = math.max(calculatedTextSize + 8, 20) -- Minimum 20px height
        		label.Size = UDim2.new(1, 0, 0, labelHeight)
        		-- Don't set Position for accordion labels - let UIListLayout handle it
        		label.TextSize = calculatedTextSize
        		label.ZIndex = 5
        		-- No debug background needed
        	else
        		label.Size = UDim2.new(1, -20, 0, 30)
        		label.Position = UDim2.new(0, 10, 0, currentY)
        		label.TextSize = textSize or 16
        		label.ZIndex = 3
        		label:SetAttribute("ComponentStartY", currentY)
        	end
        	label.BackgroundTransparency = 1
        	local labelText = type(text) == "function" and text() or text
        	label.Text = tostring(labelText or "")
        	label.TextColor3 = textColor or Colors.Text.Primary

        	-- Debug: Ensure text is visible by using a contrasting color for accordion labels
        	if isForAccordion and not textColor then
        		label.TextColor3 = Color3.fromRGB(255, 255, 255) -- White text for accordion labels
        	end
        	label.TextXAlignment = Enum.TextXAlignment.Left
        	label.Font = Enum.Font.SourceSans
        	label.Visible = true -- Ensure label is visible
        	label.Parent = parentContainer

        	-- Store the text source (function or string)
        	local textSource = text
        	local updateConnection = nil

        	-- Create Label API
        	local labelAPI = {
        		Label = label
        	}

        	-- Function to update text from source
        	local function updateText()
        		if type(textSource) == "function" then
        			local success, result = pcall(textSource)
        			if success then
        				label.Text = tostring(result)
        			else
        				label.Text = "[Error]"
        			end
        		else
        			label.Text = tostring(textSource or "")
        		end
        	end

        	function labelAPI:SetText(newText)
        		textSource = newText
        		updateText()
        	end

        	function labelAPI:GetText()
        		return label.Text
        	end

        	function labelAPI:SetTextColor(color)
        		label.TextColor3 = color
        	end

        	function labelAPI:SetTextSize(size)
        		label.TextSize = size
        		-- Update label height if in accordion
        		if isForAccordion then
        			local labelHeight = math.max(size + 8, 20)
        			label.Size = UDim2.new(1, 0, 0, labelHeight)
        		end
        	end

        	function labelAPI:GetHeight()
        		return label.AbsoluteSize.Y
        	end

        	-- Start auto-update if text is a function
        	function labelAPI:StartAutoUpdate(interval)
        		interval = interval or 1

        		if updateConnection then
        			updateConnection:Disconnect()
        		end

        		if type(textSource) == "function" then
        			local RunService = game:GetService("RunService")
        			local lastUpdate = 0

        			updateConnection = RunService.Heartbeat:Connect(function()
        				local currentTime = tick()
        				if currentTime - lastUpdate >= interval then
        					updateText()
        					lastUpdate = currentTime
        				end
        			end)
        		end
        	end

        	function labelAPI:StopAutoUpdate()
        		if updateConnection then
        			updateConnection:Disconnect()
        			updateConnection = nil
        		end
        	end

        	function labelAPI:Update()
        		updateText()
        	end

        	-- Cleanup when label is destroyed
        	label.AncestryChanged:Connect(function()
        		if not label.Parent then
        			labelAPI:StopAutoUpdate()
        		end
        	end)

        	-- If text is a function, start auto-update by default
        	if type(textSource) == "function" then
        		labelAPI:StartAutoUpdate(1)
        	end

        	return labelAPI
        end

        return Label

    end

    -- Load module helper function
    local function loadModule(url)
        -- Try embedded module first
        if EmbeddedModules[url] then
            return EmbeddedModules[url]()
        end

        -- Fallback to original require
        return require(url)
    end

    -- Main Script
    --[[
    	EzUI - Easy Roblox UI Library
    	Main Entry Point

    	A modern, modular UI library for Roblox with:
    	- Centralized color palette system
    	- Configuration management with auto-save/load
    	- 10+ UI components
    	- Tab system with icons
    	- Window management with drag & resize

    	Usage:
    		local EzUI = require(game.ReplicatedStorage.main)

    		local window = EzUI.({
    			Name = "My UI",
    			Size = {Width = 500, Height = 400}
    		})

    		local tab = window:AddTab("Home")
    		tab:AddButton("Click Me", function()
    		end)
    ]]

    local EzUI = {}

    -- Import utility modules
    local ColorsModule = loadModule("utils/colors")
    local ConfigModule = loadModule("utils/config")

    -- Debug: Verify Colors loaded
    if ColorsModule then
    	if ColorsModule.Background then
    	else
    	end
    else
    end

    -- Import components
    local Accordion = loadModule("components/accordion")
    local Button = loadModule("components/button")
    local Label = loadModule("components/label")
    local NumberBox = loadModule("components/numberbox")
    local Notification = loadModule("components/notification")
    local SelectBox = loadModule("components/selectbox")
    local Separator = loadModule("components/separator")
    local Tab = loadModule("components/tab")
    local TextBox = loadModule("components/textbox")
    local Toggle = loadModule("components/toggle")
    local Window = loadModule("components/window")

    -- Custom Configuration System
    function EzUI:NewConfig(config)
    	return ConfigModule:NewConfig(config)
    end

    -- Initialize Components
    Accordion:Init(ColorsModule, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    Button:Init(ColorsModule)
    Label:Init(ColorsModule)
    NumberBox:Init(ColorsModule)
    SelectBox:Init(ColorsModule)
    Separator:Init(ColorsModule)
    Tab:Init(ColorsModule, Accordion, Button, Toggle, TextBox, NumberBox, SelectBox, Label, Separator)
    TextBox:Init(ColorsModule)
    Toggle:Init(ColorsModule)
    Window:Init(ColorsModule, Accordion, Button, Label, NumberBox, Notification, SelectBox, Separator, Tab, TextBox, Toggle)

    -- Main Window Creation Function
    function EzUI:CreateNew(config)
    	if not config or type(config) ~= "table" then
    		config = {}
    	end


    	-- Pass all required modules and config to Window component
    	local windowSetup = {
    		Title = config.Title or config.Name or "EzUI Window",
    		Width = config.Width or (config.Size and config.Size.Width) or 600,
    		Height = config.Height or (config.Size and config.Size.Height) or 400,
    		Opacity = config.Opacity or 0.9,
    		AutoShow = config.AutoShow or true,
    		AutoAdapt = config.AutoAdapt or true,
    		Draggable = config.Draggable,
    		BackgroundColor = config.BackgroundColor,
    		CornerRadius = config.CornerRadius,
    	}

    	-- Create config system
    	local configSystem = ConfigModule:NewConfig({
    		FolderName = config.FolderName or "EzUI",
    		FileName = config.FileName or "Settings",
    	})

    	configSystem:Load()

    	local allKeys = configSystem:GetAllKeys()

    	-- Store config in EzUI for global access
    	windowSetup.Settings = configSystem

    	return Window:Create(windowSetup)
    end

    -- Expose version info
    EzUI.Version = "2.0.0"
    EzUI.Author = "EzUI Library"

    return EzUI
end

-- Module: ../module/core.lua
EmbeddedModules["../module/core.lua"] = function()
    local m = {}

    -- Services
    m.Players = game:GetService("Players")
    m.ReplicatedStorage = game:GetService("ReplicatedStorage")
    m.TeleportService = game:GetService("TeleportService")
    m.UserInputService = game:GetService("UserInputService")
    m.GuiService = game:GetService("GuiService")
    m.Workspace = game:GetService("Workspace")
    m.VirtualUser = game:GetService("VirtualUser")
    m.MarketplaceService = game:GetService("MarketplaceService")
    m.PlaceId = game.PlaceId
    m.JobId = game.JobId
    m.IsWindowOpen = false

    -- Player reference
    m.LocalPlayer = m.Players.LocalPlayer

    -- Dynamic getters
    function m:GetCharacter()
        return self.LocalPlayer.Character
    end

    function m:GetHumanoid()
        local char = self:GetCharacter()
        return char and char:FindFirstChildOfClass("Humanoid") or nil
    end

    function m:GetHumanoidRootPart()
        local char = self:GetCharacter()
        return char and char:FindFirstChild("HumanoidRootPart") or nil
    end

    function m:GetBackpack()
        return self.LocalPlayer:FindFirstChild("Backpack")
    end

    function m:GetPlayerGui()
        return self.LocalPlayer:FindFirstChild("PlayerGui")
    end

    function m:Rejoin()
        if self.PlaceId and self.JobId then
            self.TeleportService:TeleportToPlaceInstance(self.PlaceId, self.JobId, self.LocalPlayer)
        else
            warn("Core:Rejoin - PlaceId or JobId is nil, cannot rejoin.")
        end
    end

    function m:HopServer()
        if self.PlaceId then
            self.TeleportService:Teleport(self.PlaceId, self.LocalPlayer)
        else
            warn("Core:HopServer - PlaceId is nil, cannot hop server.")
        end
    end

    -- Table to track active loops
    local activeLoops = {}

    function m:MakeLoop(_isEnableFunc, _func, _delay)
        _delay = _delay or 3 -- Ensure default delay is applied

        local loop = coroutine.create(function()
            local lastCheck = 0
            local checkInterval = 5 -- Check config every 5 seconds instead of every 0.1 seconds

            while self.IsWindowOpen do
                local currentTime = tick()
                local isEnabled = false

                -- Only check config periodically to reduce overhead
                if currentTime - lastCheck >= checkInterval then
                    -- Handle both function and direct value
                    if type(_isEnableFunc) == "function" then
                        isEnabled = _isEnableFunc()
                    else
                        isEnabled = _isEnableFunc
                    end
                    lastCheck = currentTime
                end

                if not isEnabled then
                    task.wait(5) -- Longer wait when disabled
                    continue
                end

                _func()
                task.wait(_delay) -- Use validated delay
            end
        end)

        table.insert(activeLoops, loop)
        coroutine.resume(loop)
        return loop
    end

    function m:StopAllLoops()
        for _, loop in ipairs(activeLoops) do
            if loop and coroutine.status(loop) ~= "dead" then
                coroutine.close(loop)
            end
        end
        table.clear(activeLoops)
    end
    return m
end

-- Module: teleport/ui.lua
EmbeddedModules["teleport/ui.lua"] = function()
    local m = {}

    local Window
    local Core
    local Player
    local NPC
    local Spot
    local CustomPositionConfig
    local TeleportEvent

    function m:Init(_window, _core, _player, _npc, _spot, _customPositionConfig, _teleportEvent)
        Window = _window
        Core = _core
        Player = _player
        NPC = _npc
        Spot = _spot
        CustomPositionConfig = _customPositionConfig
        TeleportEvent = _teleportEvent

        local tab = Window:AddTab({
            Name = "Teleport",
            Icon = "📍",
        })

        self:LockPositionSection(tab)
        self:EventSection(tab)
        self:FishingSpotsSection(tab)
        self:PlayerSection(tab)
        self:NPCSection(tab)
        self:CustomSection(tab)
    end

    function m:LockPositionSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Lock Position",
            Icon = "📌",
            Default = false,
        })

        local textBoxLockPotision = accordion:AddTextBox({
            Name = "Lock Position",
            Default = "",
            Placeholder = "Enter position...",
            Flag = "LockPlayerPosition",
            MaxLength = 200,
        })

        accordion:AddButton({
            Name = "Get Current Position",
            Callback = function()
                local position = Player:GetPosition()
                textBoxLockPotision:SetText(tostring(position))
            end
        })

        accordion:AddToggle({
            Name = "Lock Player 📌",
            Default = false,
            Flag = "LockPlayer",
        })
    end

    function m:FishingSpotsSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Fishing Spots",
            Icon = "🎣",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Fishing Spot to Teleport",
            Options = {"Loading..."},
            Placeholder = "Select Fishing Spot...",
            MultiSelect = false,
            Flag = "TeleportToFishingSpot",
            OnInit = function(api, optionsData)
                local fishingSpots = Spot:GetAllFishingSpots()
                local formattedSpots = {}
                for _, spotData in pairs(fishingSpots) do
                    table.insert(formattedSpots, {text = string.format("%s - [Base Luck: %.2f] [Power: %.2f]", spotData.Name, spotData.BaseLuck or 0, spotData.ClickPowerMultiplier or 0), value = spotData.Name})
                end

                table.sort(formattedSpots, function(a, b)
                    return a.value < b.value
                end)
                optionsData.updateOptions(formattedSpots)
            end
        })

        accordion:AddButton({
            Name = "Teleport to Selected Fishing Spot",
            Callback = function()
                local selectedSpots = Window:GetConfigValue("TeleportToFishingSpot")
                if not selectedSpots then
                    return
                end

                local spotData = Spot:FindSpotByName(selectedSpots)
                if not spotData then
                    return
                end
                Player:TeleportToPosition(spotData.Position)
            end
        })
    end

    function m:EventSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Event Teleport",
            Icon = "🎉",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Event to Teleport",
            Options = {"Loading..."},
            Placeholder = "Select Event...",
            MultiSelect = false,
            Flag = "TeleportEvent",
            OnInit = function(api, optionsData)
                local events = TeleportEvent:GetListEvents()
                local formattedEvents = {}
                for _, eventData in pairs(events) do
                    table.insert(formattedEvents, eventData.Name)
                end

                table.sort(formattedEvents)
                optionsData.updateOptions(formattedEvents)
            end
        })

        accordion:AddToggle({
            Name = "Auto Teleport to Event",
            Default = false,
            Flag = "AutoTeleportToEvent",
            Callback = function(value)
                TeleportEvent.IsOnEvent = value
                if value then
                    TeleportEvent:TeleportToEvent()
                end
            end
        })
    end

    function m:PlayerSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Player",
            Icon = "🧑",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select Player to Teleport",
            Options = {"Loading..."},
            Placeholder = "Select Player...",
            MultiSelect = false,
            Flag = "TeleportToPlayerUsername",
            OnDropdownOpen = function(currentOptions, updateOptions)
                local players = Core.Players:GetChildren()
                local formattedPlayers = {}

                for _, playerData in pairs(players) do
                    if playerData == Core.LocalPlayer then
                        continue
                    end
                    table.insert(formattedPlayers, playerData.Name)
                end

                table.sort(formattedPlayers)

                updateOptions(formattedPlayers)
            end
        })

        accordion:AddButton({
            Name = "Teleport to Player",
            Callback = function()
                local username = Window:GetConfigValue("TeleportToPlayerUsername")
                local players = Core.Players:GetChildren()

                if not username or username == "" then
                    return
                end

                for _, playerData in pairs(players) do
                    if playerData.Name == username then
                        local character = playerData.Character
                        if not character then
                            return
                        end

                        local hrp = character:FindFirstChild("HumanoidRootPart")
                        if not hrp then
                            return
                        end

                        Player:TeleportToPosition(hrp.CFrame)
                        return
                    end
                end
            end
        })
    end

    function m:NPCSection(tab)
        local accordion = tab:AddAccordion({
            Title = "NPC",
            Icon = "👨‍👩‍👧‍👦",
            Default = false,
        })

        accordion:AddSelectBox({
            Name = "Select NPC to Teleport",
            Options = {"Loading..."},
            Placeholder = "Select NPC...",
            MultiSelect = false,
            Flag = "TeleportToNPC",
            OnInit = function(api, optionsData)
                local npcs = NPC:ListNPCRepository()
                local formattedNpcs = {}
                for _, npcData in pairs(npcs) do
                    table.insert(formattedNpcs, npcData.Name)
                end

                table.sort(formattedNpcs)
                optionsData.updateOptions(formattedNpcs)
            end
        })

        accordion:AddButton({
            Name = "Teleport to Selected NPC",
            Callback = function()
                local selectedNpcs = Window:GetConfigValue("TeleportToNPC")
                if not selectedNpcs then
                    return
                end

                local npcData = NPC:FindNPCByName(selectedNpcs)
                if not npcData then
                    return
                end
                Player:TeleportToPosition(Vector3.new(npcData.Position.X, npcData.Position.Y + 5, npcData.Position.Z))
            end
        })
    end

    function m:CustomSection(tab)
        local accordion = tab:AddAccordion({
            Title = "Custom Teleport",
            Icon = "🛠️",
            Default = false,
        })

        local textBoxPosition = accordion:AddTextBox({
            Name = "Custom Position",
            Default = "",
            Placeholder = "Enter position...",
            Flag = "CustomTeleportPosition",
            MaxLength = 200,
        })

        accordion:AddButton({
            Name = "Get Current Position",
            Callback = function()
                local position = Player:GetPosition()
                textBoxPosition:SetText(tostring(position))
            end
        })

        local textBoxPositionName = accordion:AddTextBox({
            Name = "Position Name",
            Default = "",
            Placeholder = "Enter a name for this position...",
            MaxLength = 50,
        })

        accordion:AddButton({
            Name = "Save Custom Position",
            Callback = function()
                local position = textBoxPosition:GetText()
                local positionName = textBoxPositionName:GetText()
                if not position or positionName == "" then
                    return
                end

                CustomPositionConfig:SetValue(positionName, position)

                position.Clear()()
                positionName.Clear()
            end
        })

        accordion:AddSeparator()

        accordion:AddSelectBox({
            Name = "Select Custom Position to Teleport",
            Options = {"Loading..."},
            Placeholder = "Select Custom Position...",
            MultiSelect = false,
            Flag = "TeleportToCustomPosition",
            OnDropdownOpen = function(currentOptions, updateOptions)
                local customPositions = CustomPositionConfig:GetAllKeys()
                table.sort(customPositions)
                updateOptions(customPositions)
            end
        })

        accordion:AddButton({
            Name = "Teleport to Selected Custom Position",
            Callback = function()
                local selectedPositionName = Window:GetConfigValue("TeleportToCustomPosition")
                if not selectedPositionName then
                    return
                end

                local positionString = CustomPositionConfig:GetValue(selectedPositionName)
                if not positionString then
                    return
                end

                local position = load("return " .. positionString)()
                if not position then
                    return
                end

                Player:TeleportToPosition(position)
            end
        })

        accordion:AddButton({
            Name = "Delete Selected Custom Position",
            variant = "danger",
            Callback = function()
                local selectedPositionName = Window:GetConfigValue("TeleportToCustomPosition")
                if not selectedPositionName then
                    return
                end

                CustomPositionConfig:DeleteKey(selectedPositionName)
            end
        })
    end

    return m
end

-- Module: auto/trick_or_treat.lua
EmbeddedModules["auto/trick_or_treat.lua"] = function()
    local m = {}
    local Window
    local Core
    local NPC

    local Net
    local CurrentDelayTime = 0

    function m:Init(_window, _core, _npc)
        Window = _window
        Core = _core
        NPC = _npc

        Net = require(Core.ReplicatedStorage.Packages.Net)

        Core:MakeLoop(
            function()
                return Window:GetConfigValue("AutoTrickOrTreat")
            end,
            function()
                self:StartAutoTrickOrTreat()
            end
        )
    end

    function m:StartAutoTrickOrTreat()
        if not Window:GetConfigValue("AutoTrickOrTreat") then
            return
        end

        local npcData = NPC:ListNPCRepository()

        for _, npc in pairs(npcData) do
            Net:RemoteFunction("SpecialDialogueEvent"):InvokeServer(
                npc.Name,
                "TrickOrTreat"
            )
        end
        CurrentDelayTime = 7200

        while CurrentDelayTime > 0 and Window:GetConfigValue("AutoTrickOrTreat") do
            task.wait(1)
            CurrentDelayTime = CurrentDelayTime - 1
        end
    end

    return m
end

-- Load module helper function
local function loadModule(url)
    -- Try embedded module first
    if EmbeddedModules[url] then
        return EmbeddedModules[url]()
    end
    
    -- Fallback to original require
    return require(url)
end

-- Main Script
-- Main entry point
local EzUI = loadModule("https://github.com/alfin-efendy/ez-rbx-ui/releases/latest/download/ez-rbx-ui.lua")
-- Import local modules
local CoreModule = loadModule("../module/core.lua")
local PlayerModule = loadModule("../module/player.lua")
local Discord = loadModule("../module/discord.lua")

-- Farm modules
local FishingModule = loadModule("farm/fishing.lua")
local WebhookFarmModule = loadModule("farm/webhook.lua")
local InventoryModule = loadModule("farm/inventory.lua")
local FarmUI = loadModule("farm/ui.lua")

-- Teleport modules
local LockModule = loadModule("teleport/lock.lua")
local SpotModule = loadModule("teleport/spot.lua")
local TeleportEvent = loadModule("teleport/event.lua")
local NPCModule = loadModule("teleport/npc.lua")
local TeleportUI = loadModule("teleport/ui.lua")

-- Auto modules
local TrickOrTreatModule = loadModule("auto/trick_or_treat.lua")
local EventsModule = loadModule("auto/events.lua")
local EnchantModule = loadModule("auto/enchant.lua")
local TradeModule = loadModule("auto/trade.lua")
local AutoUI = loadModule("auto/ui.lua")

-- Notification modules
local WebhookNotificationModule = loadModule("notification/webhook.lua")
local NotificationUI = loadModule("notification/ui.lua")

-- Misc modules
local DisableModule = loadModule("misc/disable.lua")
local MiscUI = loadModule("misc/ui.lua")

local configFolder = "EzHub/EzFish-It"

-- Initialize window
local window = EzUI:CreateNew({
    Title = "EzFish-It",
    Width = 700,
    Height = 400,
    Opacity = 0.9,
    AutoAdapt = true,
    AutoShow = false,
    FolderName = configFolder,
    FileName = "settings",
})

window:SetCloseCallback(function()
    CoreModule.IsWindowOpen = false

    -- Remove Anti-AFK connections
    PlayerModule:RemoveAntiAFK()

    -- Stop all queued tasks
    PlayerModule:ClearQueue()

    -- Stop all active loops
    CoreModule:StopAllLoops()

    FishingModule:StopAutoFishing()
end)

customPositionConfig = EzUI:NewConfig({
    FolderName = configFolder,
    FileName = "CustomPositions",
})

customPositionConfig:Load()

-- Wait load config
task.wait(1) -- Ensure config is loaded

-- Core
CoreModule.IsWindowOpen = true
-- Player
PlayerModule:Init(CoreModule)

-- Teleport
TeleportEvent:Init(window, CoreModule, PlayerModule)
LockModule:Init(window, CoreModule, PlayerModule, TeleportEvent)
SpotModule:Init(CoreModule)
NPCModule:Init(window, CoreModule)

-- Farm
FishingModule:Init(window, CoreModule)
WebhookFarmModule:Init(window, CoreModule, Discord)
InventoryModule:Init(window, CoreModule, WebhookFarmModule)

-- Auto
TrickOrTreatModule:Init(window, CoreModule, NPCModule)
EventsModule:Init(window, CoreModule)
TradeModule:Init(window, CoreModule)
EnchantModule:Init(window, CoreModule, PlayerModule)

-- Notification
WebhookNotificationModule:Init(window, CoreModule, Discord)

-- Misc
DisableModule:Init(window, CoreModule)

FarmUI:Init(window, CoreModule, FishingModule, InventoryModule)
TeleportUI:Init(window, CoreModule, PlayerModule, NPCModule, SpotModule, customPositionConfig, TeleportEvent)
AutoUI:Init(window, CoreModule, EventsModule, EnchantModule, TradeModule)
NotificationUI:Init(window, CoreModule, WebhookNotificationModule)
MiscUI:Init(window, CoreModule, DisableModule)
